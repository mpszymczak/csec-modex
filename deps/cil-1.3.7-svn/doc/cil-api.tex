\documentclass[11pt]{article} 
\usepackage[latin1]{inputenc} 
\setlength{\pdfpagewidth}{\paperwidth} \setlength{\pdfpageheight}{\paperheight} 
\usepackage{fullpage} 
\usepackage{url} 
\usepackage{ocamldoc}
\title{CIL API Documentation (version 1.3.7)}
\begin{document}
\maketitle
\tableofcontents
\section{Module {\tt{Pretty}} : Utility functions for pretty-printing.}
\label{module:Pretty}\index{Pretty@\verb`Pretty`}
 The major features provided by 
    this module are \begin{itemize}
\item An {\tt{fprintf}}-style interface with support for user-defined printers
\item The printout is fit to a width by selecting some of the optional newlines
\item Constructs for alignment and indentation
\item Print ellipsis starting at a certain nesting depth
\item Constructs for printing lists and arrays
\end{itemize}

 Pretty-printing occurs in two stages:\begin{itemize}
\item Construct a {\tt{Pretty.doc}}[\ref{type:Pretty.doc}] object that encodes all of the elements to be 
  printed 
  along with alignment specifiers and optional and mandatory newlines
\item Format the {\tt{Pretty.doc}}[\ref{type:Pretty.doc}] to a certain width and emit it as a string, to an 
  output stream or pass it to a user-defined function
\end{itemize}

 The formatting algorithm is not optimal but it does a pretty good job while 
 still operating in linear time. The original version was based on a pretty 
 printer by Philip Wadler which turned out to not scale to large jobs.



\ocamldocvspace{0.5cm}



API



\label{type:Pretty.doc}\begin{ocamldoccode}
type doc 
\end{ocamldoccode}
\index{doc@\verb`doc`}
\begin{ocamldocdescription}
The type of unformated documents. Elements of this type can be 
 constructed in two ways. Either with a number of constructor shown below, 
 or using the {\tt{Pretty.dprintf}}[\ref{val:Pretty.dprintf}] function with a {\tt{printf}}-like interface. 
 The {\tt{Pretty.dprintf}}[\ref{val:Pretty.dprintf}] method is slightly slower so we do not use it for 
 large jobs such as the output routines for a compiler. But we use it for 
 small jobs such as logging and error messages.


\end{ocamldocdescription}




Constructors for the doc type.



\label{val:Pretty.nil}\begin{ocamldoccode}
val nil : doc
\end{ocamldoccode}
\index{nil@\verb`nil`}
\begin{ocamldocdescription}
Constructs an empty document


\end{ocamldocdescription}




\label{val:Pretty.(-plus-plus)}\begin{ocamldoccode}
val (++) : doc -> doc -> doc
\end{ocamldoccode}
\index{(-plus-plus)@\verb`(++)`}
\begin{ocamldocdescription}
Concatenates two documents. This is an infix operator that associates to 
    the left.


\end{ocamldocdescription}




\label{val:Pretty.concat}\begin{ocamldoccode}
val concat : doc -> doc -> doc
\end{ocamldoccode}
\index{concat@\verb`concat`}




\label{val:Pretty.text}\begin{ocamldoccode}
val text : string -> doc
\end{ocamldoccode}
\index{text@\verb`text`}
\begin{ocamldocdescription}
A document that prints the given string


\end{ocamldocdescription}




\label{val:Pretty.num}\begin{ocamldoccode}
val num : int -> doc
\end{ocamldoccode}
\index{num@\verb`num`}
\begin{ocamldocdescription}
A document that prints an integer in decimal form


\end{ocamldocdescription}




\label{val:Pretty.num64}\begin{ocamldoccode}
val num64 : int64 -> doc
\end{ocamldoccode}
\index{num64@\verb`num64`}
\begin{ocamldocdescription}
A document that prints a 64-bit int in decimal form


\end{ocamldocdescription}




\label{val:Pretty.real}\begin{ocamldoccode}
val real : float -> doc
\end{ocamldoccode}
\index{real@\verb`real`}
\begin{ocamldocdescription}
A document that prints a real number


\end{ocamldocdescription}




\label{val:Pretty.chr}\begin{ocamldoccode}
val chr : char -> doc
\end{ocamldoccode}
\index{chr@\verb`chr`}
\begin{ocamldocdescription}
A document that prints a character. This is just like {\tt{Pretty.text}}[\ref{val:Pretty.text}]
    with a one-character string.


\end{ocamldocdescription}




\label{val:Pretty.line}\begin{ocamldoccode}
val line : doc
\end{ocamldoccode}
\index{line@\verb`line`}
\begin{ocamldocdescription}
A document that consists of a mandatory newline. This is just like {\tt{(text\
    "{\textbackslash}n")}}. The new line will be indented to the current indentation level,
    unless you use {\tt{Pretty.leftflush}}[\ref{val:Pretty.leftflush}] right after this.


\end{ocamldocdescription}




\label{val:Pretty.leftflush}\begin{ocamldoccode}
val leftflush : doc
\end{ocamldoccode}
\index{leftflush@\verb`leftflush`}
\begin{ocamldocdescription}
Use after a {\tt{Pretty.line}}[\ref{val:Pretty.line}] to prevent the indentation. Whatever follows 
 next will be flushed left. Indentation resumes on the next line.


\end{ocamldocdescription}




\label{val:Pretty.break}\begin{ocamldoccode}
val break : doc
\end{ocamldoccode}
\index{break@\verb`break`}
\begin{ocamldocdescription}
A document that consists of either a space or a line break. Also called
    an optional line break. Such a break will be
    taken only if necessary to fit the document in a given width. If the break
    is not taken a space is printed instead.


\end{ocamldocdescription}




\label{val:Pretty.align}\begin{ocamldoccode}
val align : doc
\end{ocamldoccode}
\index{align@\verb`align`}
\begin{ocamldocdescription}
Mark the current column as the current indentation level. Does not print
    anything. All taken line breaks will align to this column. The previous
    alignment level is saved on a stack.


\end{ocamldocdescription}




\label{val:Pretty.unalign}\begin{ocamldoccode}
val unalign : doc
\end{ocamldoccode}
\index{unalign@\verb`unalign`}
\begin{ocamldocdescription}
Reverts to the last saved indentation level.


\end{ocamldocdescription}




\label{val:Pretty.mark}\begin{ocamldoccode}
val mark : doc
\end{ocamldoccode}
\index{mark@\verb`mark`}
\begin{ocamldocdescription}
Mark the beginning of a markup section. The width of a markup section is 
 considered 0 for the purpose of computing identation


\end{ocamldocdescription}




\label{val:Pretty.unmark}\begin{ocamldoccode}
val unmark : doc
\end{ocamldoccode}
\index{unmark@\verb`unmark`}
\begin{ocamldocdescription}
The end of a markup section


\end{ocamldocdescription}




Syntactic sugar



\label{val:Pretty.indent}\begin{ocamldoccode}
val indent : int -> doc -> doc
\end{ocamldoccode}
\index{indent@\verb`indent`}
\begin{ocamldocdescription}
Indents the document. Same as {\tt{((text "  ") ++ align ++ doc ++ unalign)}},
    with the specified number of spaces.


\end{ocamldocdescription}




\label{val:Pretty.markup}\begin{ocamldoccode}
val markup : doc -> doc
\end{ocamldoccode}
\index{markup@\verb`markup`}
\begin{ocamldocdescription}
Prints a document as markup. The marked document cannot contain line 
 breaks or alignment constructs.


\end{ocamldocdescription}




\label{val:Pretty.seq}\begin{ocamldoccode}
val seq : sep:doc -> doit:('a -> doc) -> elements:'a list -> doc
\end{ocamldoccode}
\index{seq@\verb`seq`}
\begin{ocamldocdescription}
Formats a sequence. {\tt{sep}} is a separator, {\tt{doit}} is a function that 
 converts an element to a document.


\end{ocamldocdescription}




\label{val:Pretty.docList}\begin{ocamldoccode}
val docList : ?sep:doc -> ('a -> doc) -> unit -> 'a list -> doc
\end{ocamldoccode}
\index{docList@\verb`docList`}
\begin{ocamldocdescription}
An alternative function for printing a list. The {\tt{unit}} argument is there 
 to make this function more easily usable with the {\tt{Pretty.dprintf}}[\ref{val:Pretty.dprintf}] 
 interface. The first argument is a separator, by default a comma.


\end{ocamldocdescription}




\label{val:Pretty.d-underscorelist}\begin{ocamldoccode}
val d_list : string -> (unit -> 'a -> doc) -> unit -> 'a list -> doc
\end{ocamldoccode}
\index{d-underscorelist@\verb`d_list`}
\begin{ocamldocdescription}
sm: Yet another list printer.  This one accepts the same kind of
 printing function that {\tt{Pretty.dprintf}}[\ref{val:Pretty.dprintf}] does, and itself works 
 in the dprintf context.  Also accepts
 a string as the separator since that's by far the most common.


\end{ocamldocdescription}




\label{val:Pretty.docArray}\begin{ocamldoccode}
val docArray : ?sep:doc ->
  (int -> 'a -> doc) -> unit -> 'a array -> doc
\end{ocamldoccode}
\index{docArray@\verb`docArray`}
\begin{ocamldocdescription}
Formats an array. A separator and a function that prints an array
    element. The default separator is a comma.


\end{ocamldocdescription}




\label{val:Pretty.docOpt}\begin{ocamldoccode}
val docOpt : ('a -> doc) -> unit -> 'a option -> doc
\end{ocamldoccode}
\index{docOpt@\verb`docOpt`}
\begin{ocamldocdescription}
Prints an {\tt{'a option}} with {\tt{None}} or {\tt{Some}}


\end{ocamldocdescription}




\label{val:Pretty.d-underscoreint32}\begin{ocamldoccode}
val d_int32 : int32 -> doc
\end{ocamldoccode}
\index{d-underscoreint32@\verb`d_int32`}
\begin{ocamldocdescription}
Print an int32


\end{ocamldocdescription}




\label{val:Pretty.f-underscoreint32}\begin{ocamldoccode}
val f_int32 : unit -> int32 -> doc
\end{ocamldoccode}
\index{f-underscoreint32@\verb`f_int32`}




\label{val:Pretty.d-underscoreint64}\begin{ocamldoccode}
val d_int64 : int64 -> doc
\end{ocamldoccode}
\index{d-underscoreint64@\verb`d_int64`}




\label{val:Pretty.f-underscoreint64}\begin{ocamldoccode}
val f_int64 : unit -> int64 -> doc
\end{ocamldoccode}
\index{f-underscoreint64@\verb`f_int64`}




\begin{ocamldoccode}
{\tt{module }}{\tt{MakeMapPrinter}}{\tt{ : }}\end{ocamldoccode}
\label{module:Pretty.MakeMapPrinter}\index{MakeMapPrinter@\verb`MakeMapPrinter`}

{\tt{functor (}}{\tt{Map}}{\tt{ : }}\begin{ocamldocsigend}


\label{type:Pretty.MakeMapPrinter.key}\begin{ocamldoccode}
type key 
\end{ocamldoccode}
\index{key@\verb`key`}


\label{type:Pretty.MakeMapPrinter.t}\begin{ocamldoccode}
type 'a t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:Pretty.MakeMapPrinter.fold}\begin{ocamldoccode}
val fold : (key -> 'a -> 'b -> 'b) ->
  'a t -> 'b -> 'b
\end{ocamldoccode}
\index{fold@\verb`fold`}
\end{ocamldocsigend}
{\tt{) -> }}\begin{ocamldocsigend}


\label{val:Pretty.MakeMapPrinter.docMap}\begin{ocamldoccode}
val docMap :
  ?sep:Pretty.doc ->
  (Map.key -> 'a -> Pretty.doc) -> unit -> 'a Map.t -> Pretty.doc
\end{ocamldoccode}
\index{docMap@\verb`docMap`}
\begin{ocamldocdescription}
Format a map, analogous to docList.


\end{ocamldocdescription}


\label{val:Pretty.MakeMapPrinter.d-underscoremap}\begin{ocamldoccode}
val d_map :
  ?dmaplet:(Pretty.doc -> Pretty.doc -> Pretty.doc) ->
  string ->
  (unit -> Map.key -> Pretty.doc) ->
  (unit -> 'a -> Pretty.doc) -> unit -> 'a Map.t -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoremap@\verb`d_map`}
\begin{ocamldocdescription}
Format a map, analogous to d\_list.


\end{ocamldocdescription}
\end{ocamldocsigend}




\begin{ocamldocdescription}
Format maps.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{MakeSetPrinter}}{\tt{ : }}\end{ocamldoccode}
\label{module:Pretty.MakeSetPrinter}\index{MakeSetPrinter@\verb`MakeSetPrinter`}

{\tt{functor (}}{\tt{Set}}{\tt{ : }}\begin{ocamldocsigend}


\label{type:Pretty.MakeSetPrinter.elt}\begin{ocamldoccode}
type elt 
\end{ocamldoccode}
\index{elt@\verb`elt`}


\label{type:Pretty.MakeSetPrinter.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:Pretty.MakeSetPrinter.fold}\begin{ocamldoccode}
val fold : (elt -> 'a -> 'a) ->
  t -> 'a -> 'a
\end{ocamldoccode}
\index{fold@\verb`fold`}
\end{ocamldocsigend}
{\tt{) -> }}\begin{ocamldocsigend}


\label{val:Pretty.MakeSetPrinter.docSet}\begin{ocamldoccode}
val docSet :
  ?sep:Pretty.doc -> (Set.elt -> Pretty.doc) -> unit -> Set.t -> Pretty.doc
\end{ocamldoccode}
\index{docSet@\verb`docSet`}
\begin{ocamldocdescription}
Format a set, analogous to docList.


\end{ocamldocdescription}


\label{val:Pretty.MakeSetPrinter.d-underscoreset}\begin{ocamldoccode}
val d_set :
  string -> (unit -> Set.elt -> Pretty.doc) -> unit -> Set.t -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreset@\verb`d_set`}
\begin{ocamldocdescription}
Format a set, analogous to d\_list.


\end{ocamldocdescription}
\end{ocamldocsigend}




\begin{ocamldocdescription}
Format sets.


\end{ocamldocdescription}




\label{val:Pretty.insert}\begin{ocamldoccode}
val insert : unit -> doc -> doc
\end{ocamldoccode}
\index{insert@\verb`insert`}
\begin{ocamldocdescription}
A function that is useful with the {\tt{printf}}-like interface


\end{ocamldocdescription}




\label{val:Pretty.dprintf}\begin{ocamldoccode}
val dprintf : ('a, unit, doc, doc) format4 -> 'a
\end{ocamldoccode}
\index{dprintf@\verb`dprintf`}
\begin{ocamldocdescription}
This function provides an alternative method for constructing 
    {\tt{doc}} objects. The first argument for this function is a format string 
    argument (of type {\tt{('a, unit, doc) format}}; if you insist on 
    understanding what that means see the module {\tt{Printf}}). The format string 
    is like that for the {\tt{printf}} function in C, except that it understands a 
    few more formatting controls, all starting with the @ character. 


    See the gprintf function if you want to pipe the result of dprintf into 
    some other functions.


 The following special formatting characters are understood (these do not 
 correspond to arguments of the function):\begin{itemize}
\item  @[ Inserts an {\tt{Pretty.align}}[\ref{val:Pretty.align}]. Every format string must have matching 
        {\tt{Pretty.align}}[\ref{val:Pretty.align}] and {\tt{Pretty.unalign}}[\ref{val:Pretty.unalign}]. 
\item  @] Inserts an {\tt{Pretty.unalign}}[\ref{val:Pretty.unalign}].
\item  @!  Inserts a {\tt{Pretty.line}}[\ref{val:Pretty.line}]. Just like "{\textbackslash}n"
\item  @?  Inserts a {\tt{Pretty.break}}[\ref{val:Pretty.break}].
\item  @$<$  Inserts a {\tt{Pretty.mark}}[\ref{val:Pretty.mark}]. 
\item  @$>$  Inserts a {\tt{Pretty.unmark}}[\ref{val:Pretty.unmark}].
\item  @\textasciicircum   Inserts a {\tt{Pretty.leftflush}}[\ref{val:Pretty.leftflush}]
       Should be used immediately after @! or "{\textbackslash}n".
\item  @@ : inserts a @ character
\end{itemize}

 In addition to the usual {\tt{printf}} \% formatting characters the following two 
 new characters are supported:\begin{itemize}
\item \%t Corresponds to an argument of type {\tt{unit -> doc}}. This argument is 
     invoked to produce a document
\item \%a Corresponds to {\bf two} arguments. The first of type {\tt{unit -> 'a -> doc}} 
     and the second of type {\tt{'a}}. (The extra {\tt{unit}} is do to the 
     peculiarities of the built-in support for format strings in Ocaml. It 
     turns out that it is not a major problem.) Here is an example of how 
     you use this:
\end{itemize}

\begin{verbatim}dprintf "Name=%s, SSN=%7d, Children=@[%a@]\n"
             pers.name pers.ssn (docList (chr ',' ++ break) text)
             pers.children\end{verbatim}


 The result of {\tt{dprintf}} is a {\tt{Pretty.doc}}[\ref{type:Pretty.doc}]. You can format the document and 
 emit it using the functions {\tt{Pretty.fprint}}[\ref{val:Pretty.fprint}] and {\tt{Pretty.sprint}}[\ref{val:Pretty.sprint}].


\end{ocamldocdescription}




\label{val:Pretty.gprintf}\begin{ocamldoccode}
val gprintf : (doc -> 'a) -> ('b, unit, doc, 'a) format4 -> 'b
\end{ocamldoccode}
\index{gprintf@\verb`gprintf`}
\begin{ocamldocdescription}
Like {\tt{Pretty.dprintf}}[\ref{val:Pretty.dprintf}] but more general. It also takes a function that is 
 invoked on the constructed document but before any formatting is done. The 
 type of the format argument means that 'a is the type of the parameters of 
 this function, unit is the type of the first argument to \%a and \%t 
 formats, doc is the type of the intermediate result, and 'b is the type of 
 the result of gprintf.


\end{ocamldocdescription}




\label{val:Pretty.fprint}\begin{ocamldoccode}
val fprint : out_channel -> width:int -> doc -> unit
\end{ocamldoccode}
\index{fprint@\verb`fprint`}
\begin{ocamldocdescription}
Format the document to the given width and emit it to the given channel


\end{ocamldocdescription}




\label{val:Pretty.sprint}\begin{ocamldoccode}
val sprint : width:int -> doc -> string
\end{ocamldoccode}
\index{sprint@\verb`sprint`}
\begin{ocamldocdescription}
Format the document to the given width and emit it as a string


\end{ocamldocdescription}




\label{val:Pretty.fprintf}\begin{ocamldoccode}
val fprintf : out_channel -> ('a, unit, doc) format -> 'a
\end{ocamldoccode}
\index{fprintf@\verb`fprintf`}
\begin{ocamldocdescription}
Like {\tt{Pretty.dprintf}}[\ref{val:Pretty.dprintf}] followed by {\tt{Pretty.fprint}}[\ref{val:Pretty.fprint}]


\end{ocamldocdescription}




\label{val:Pretty.printf}\begin{ocamldoccode}
val printf : ('a, unit, doc) format -> 'a
\end{ocamldoccode}
\index{printf@\verb`printf`}
\begin{ocamldocdescription}
Like {\tt{Pretty.fprintf}}[\ref{val:Pretty.fprintf}] applied to {\tt{stdout}}


\end{ocamldocdescription}




\label{val:Pretty.eprintf}\begin{ocamldoccode}
val eprintf : ('a, unit, doc) format -> 'a
\end{ocamldoccode}
\index{eprintf@\verb`eprintf`}
\begin{ocamldocdescription}
Like {\tt{Pretty.fprintf}}[\ref{val:Pretty.fprintf}] applied to {\tt{stderr}}


\end{ocamldocdescription}




\label{val:Pretty.withPrintDepth}\begin{ocamldoccode}
val withPrintDepth : int -> (unit -> unit) -> unit
\end{ocamldoccode}
\index{withPrintDepth@\verb`withPrintDepth`}
\begin{ocamldocdescription}
Invokes a thunk, with printDepth temporarily set to the specified value


\end{ocamldocdescription}




The following variables can be used to control the operation of the printer



\label{val:Pretty.printDepth}\begin{ocamldoccode}
val printDepth : int ref
\end{ocamldoccode}
\index{printDepth@\verb`printDepth`}
\begin{ocamldocdescription}
Specifies the nesting depth of the {\tt{align}}/{\tt{unalign}} pairs at which 
    everything is replaced with ellipsis


\end{ocamldocdescription}




\label{val:Pretty.printIndent}\begin{ocamldoccode}
val printIndent : bool ref
\end{ocamldoccode}
\index{printIndent@\verb`printIndent`}
\begin{ocamldocdescription}
If false then does not indent


\end{ocamldocdescription}




\label{val:Pretty.fastMode}\begin{ocamldoccode}
val fastMode : bool ref
\end{ocamldoccode}
\index{fastMode@\verb`fastMode`}
\begin{ocamldocdescription}
If set to {\tt{true}} then optional breaks are taken only when the document 
    has exceeded the given width. This means that the printout will looked 
    more ragged but it will be faster


\end{ocamldocdescription}




\label{val:Pretty.flushOften}\begin{ocamldoccode}
val flushOften : bool ref
\end{ocamldoccode}
\index{flushOften@\verb`flushOften`}
\begin{ocamldocdescription}
If true the it flushes after every print


\end{ocamldocdescription}




\label{val:Pretty.countNewLines}\begin{ocamldoccode}
val countNewLines : int ref
\end{ocamldoccode}
\index{countNewLines@\verb`countNewLines`}
\begin{ocamldocdescription}
Keep a running count of the taken newlines. You can read and write this 
 from the client code if you want


\end{ocamldocdescription}




\label{val:Pretty.auto-underscoreprinter}\begin{ocamldoccode}
val auto_printer : string -> 'a
\end{ocamldoccode}
\index{auto-underscoreprinter@\verb`auto_printer`}
\begin{ocamldocdescription}
A function that when used at top-level in a module will direct 
 the pa\_prtype module generate automatically the printing functions for a 
 type


\end{ocamldocdescription}


\section{Module {\tt{Errormsg}} : Utility functions for error-reporting}
\label{module:Errormsg}\index{Errormsg@\verb`Errormsg`}




\ocamldocvspace{0.5cm}



\label{val:Errormsg.logChannel}\begin{ocamldoccode}
val logChannel : out_channel ref
\end{ocamldoccode}
\index{logChannel@\verb`logChannel`}
\begin{ocamldocdescription}
A channel for printing log messages


\end{ocamldocdescription}




\label{val:Errormsg.debugFlag}\begin{ocamldoccode}
val debugFlag : bool ref
\end{ocamldoccode}
\index{debugFlag@\verb`debugFlag`}
\begin{ocamldocdescription}
If set then print debugging info


\end{ocamldocdescription}




\label{val:Errormsg.verboseFlag}\begin{ocamldoccode}
val verboseFlag : bool ref
\end{ocamldoccode}
\index{verboseFlag@\verb`verboseFlag`}




\label{val:Errormsg.colorFlag}\begin{ocamldoccode}
val colorFlag : bool ref
\end{ocamldoccode}
\index{colorFlag@\verb`colorFlag`}
\begin{ocamldocdescription}
Set to true if you want error and warning messages to be colored


\end{ocamldocdescription}




\label{val:Errormsg.redEscStr}\begin{ocamldoccode}
val redEscStr : string
\end{ocamldoccode}
\index{redEscStr@\verb`redEscStr`}




\label{val:Errormsg.greenEscStr}\begin{ocamldoccode}
val greenEscStr : string
\end{ocamldoccode}
\index{greenEscStr@\verb`greenEscStr`}




\label{val:Errormsg.yellowEscStr}\begin{ocamldoccode}
val yellowEscStr : string
\end{ocamldoccode}
\index{yellowEscStr@\verb`yellowEscStr`}




\label{val:Errormsg.blueEscStr}\begin{ocamldoccode}
val blueEscStr : string
\end{ocamldoccode}
\index{blueEscStr@\verb`blueEscStr`}




\label{val:Errormsg.purpleEscStr}\begin{ocamldoccode}
val purpleEscStr : string
\end{ocamldoccode}
\index{purpleEscStr@\verb`purpleEscStr`}




\label{val:Errormsg.cyanEscStr}\begin{ocamldoccode}
val cyanEscStr : string
\end{ocamldoccode}
\index{cyanEscStr@\verb`cyanEscStr`}




\label{val:Errormsg.whiteEscStr}\begin{ocamldoccode}
val whiteEscStr : string
\end{ocamldoccode}
\index{whiteEscStr@\verb`whiteEscStr`}




\label{val:Errormsg.resetEscStr}\begin{ocamldoccode}
val resetEscStr : string
\end{ocamldoccode}
\index{resetEscStr@\verb`resetEscStr`}




\label{val:Errormsg.warnFlag}\begin{ocamldoccode}
val warnFlag : bool ref
\end{ocamldoccode}
\index{warnFlag@\verb`warnFlag`}
\begin{ocamldocdescription}
Set to true if you want to see all warnings.


\end{ocamldocdescription}




\label{exception:Errormsg.Error}\begin{ocamldoccode}
exception Error
\end{ocamldoccode}
\index{Error@\verb`Error`}
\begin{ocamldocdescription}
Error reporting functions raise this exception


\end{ocamldocdescription}




\label{val:Errormsg.error}\begin{ocamldoccode}
val error : ('a, unit, Pretty.doc, unit) format4 -> 'a
\end{ocamldoccode}
\index{error@\verb`error`}
\begin{ocamldocdescription}
Prints an error message of the form {\tt{Error: ...}}. 
    Use in conjunction with s, for example: {\tt{E.s (E.error ... )}}.


\end{ocamldocdescription}




\label{val:Errormsg.bug}\begin{ocamldoccode}
val bug : ('a, unit, Pretty.doc, unit) format4 -> 'a
\end{ocamldoccode}
\index{bug@\verb`bug`}
\begin{ocamldocdescription}
Similar to {\tt{error}} except that its output has the form {\tt{Bug: ...}}


\end{ocamldocdescription}




\label{val:Errormsg.unimp}\begin{ocamldoccode}
val unimp : ('a, unit, Pretty.doc, unit) format4 -> 'a
\end{ocamldoccode}
\index{unimp@\verb`unimp`}
\begin{ocamldocdescription}
Similar to {\tt{error}} except that its output has the form {\tt{Unimplemented: ...}}


\end{ocamldocdescription}




\label{val:Errormsg.s}\begin{ocamldoccode}
val s : 'a -> 'b
\end{ocamldoccode}
\index{s@\verb`s`}
\begin{ocamldocdescription}
Stop the execution by raising an Error.


\end{ocamldocdescription}




\label{val:Errormsg.hadErrors}\begin{ocamldoccode}
val hadErrors : bool ref
\end{ocamldoccode}
\index{hadErrors@\verb`hadErrors`}
\begin{ocamldocdescription}
This is set whenever one of the above error functions are called. It must
    be cleared manually


\end{ocamldocdescription}




\label{val:Errormsg.warn}\begin{ocamldoccode}
val warn : ('a, unit, Pretty.doc, unit) format4 -> 'a
\end{ocamldoccode}
\index{warn@\verb`warn`}
\begin{ocamldocdescription}
Like {\tt{Errormsg.error}}[\ref{val:Errormsg.error}] but does not raise the {\tt{Errormsg.Error}}[\ref{exception:Errormsg.Error}] 
 exception. Return type is unit.


\end{ocamldocdescription}




\label{val:Errormsg.warnOpt}\begin{ocamldoccode}
val warnOpt : ('a, unit, Pretty.doc, unit) format4 -> 'a
\end{ocamldoccode}
\index{warnOpt@\verb`warnOpt`}
\begin{ocamldocdescription}
Like {\tt{Errormsg.warn}}[\ref{val:Errormsg.warn}] but optional. Printed only if the 
 {\tt{Errormsg.warnFlag}}[\ref{val:Errormsg.warnFlag}] is set


\end{ocamldocdescription}




\label{val:Errormsg.log}\begin{ocamldoccode}
val log : ('a, unit, Pretty.doc, unit) format4 -> 'a
\end{ocamldoccode}
\index{log@\verb`log`}
\begin{ocamldocdescription}
Print something to {\tt{logChannel}}


\end{ocamldocdescription}




\label{val:Errormsg.logg}\begin{ocamldoccode}
val logg : ('a, unit, Pretty.doc, unit) format4 -> 'a
\end{ocamldoccode}
\index{logg@\verb`logg`}
\begin{ocamldocdescription}
same as {\tt{Errormsg.log}}[\ref{val:Errormsg.log}] but do not wrap lines


\end{ocamldocdescription}




\label{val:Errormsg.null}\begin{ocamldoccode}
val null : ('a, unit, Pretty.doc, unit) format4 -> 'a
\end{ocamldoccode}
\index{null@\verb`null`}
\begin{ocamldocdescription}
Do not actually print (i.e. print to /dev/null)


\end{ocamldocdescription}




\label{val:Errormsg.pushContext}\begin{ocamldoccode}
val pushContext : (unit -> Pretty.doc) -> unit
\end{ocamldoccode}
\index{pushContext@\verb`pushContext`}
\begin{ocamldocdescription}
Registers a context printing function


\end{ocamldocdescription}




\label{val:Errormsg.popContext}\begin{ocamldoccode}
val popContext : unit -> unit
\end{ocamldoccode}
\index{popContext@\verb`popContext`}
\begin{ocamldocdescription}
Removes the last registered context printing function


\end{ocamldocdescription}




\label{val:Errormsg.showContext}\begin{ocamldoccode}
val showContext : unit -> unit
\end{ocamldoccode}
\index{showContext@\verb`showContext`}
\begin{ocamldocdescription}
Show the context stack to stderr


\end{ocamldocdescription}




\label{val:Errormsg.withContext}\begin{ocamldoccode}
val withContext : (unit -> Pretty.doc) -> ('a -> 'b) -> 'a -> 'b
\end{ocamldoccode}
\index{withContext@\verb`withContext`}
\begin{ocamldocdescription}
To ensure that the context is registered and removed properly, use the 
    function below


\end{ocamldocdescription}




\label{val:Errormsg.newline}\begin{ocamldoccode}
val newline : unit -> unit
\end{ocamldoccode}
\index{newline@\verb`newline`}




\label{val:Errormsg.newHline}\begin{ocamldoccode}
val newHline : unit -> unit
\end{ocamldoccode}
\index{newHline@\verb`newHline`}




\label{val:Errormsg.getPosition}\begin{ocamldoccode}
val getPosition : unit -> int * string * int
\end{ocamldoccode}
\index{getPosition@\verb`getPosition`}




\label{val:Errormsg.getHPosition}\begin{ocamldoccode}
val getHPosition : unit -> int * string
\end{ocamldoccode}
\index{getHPosition@\verb`getHPosition`}
\begin{ocamldocdescription}
high-level position


\end{ocamldocdescription}




\label{val:Errormsg.setHLine}\begin{ocamldoccode}
val setHLine : int -> unit
\end{ocamldoccode}
\index{setHLine@\verb`setHLine`}




\label{val:Errormsg.setHFile}\begin{ocamldoccode}
val setHFile : string -> unit
\end{ocamldoccode}
\index{setHFile@\verb`setHFile`}




\label{val:Errormsg.setCurrentLine}\begin{ocamldoccode}
val setCurrentLine : int -> unit
\end{ocamldoccode}
\index{setCurrentLine@\verb`setCurrentLine`}




\label{val:Errormsg.setCurrentFile}\begin{ocamldoccode}
val setCurrentFile : string -> unit
\end{ocamldoccode}
\index{setCurrentFile@\verb`setCurrentFile`}




\label{type:Errormsg.location}\begin{ocamldoccode}
type location = \{
  file : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The file name
\end{ocamldoccomment}
\begin{ocamldoccode}
  line : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The line number
\end{ocamldoccomment}
\begin{ocamldoccode}
  hfile : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The high-level file name, or "" if not present
\end{ocamldoccomment}
\begin{ocamldoccode}
  hline : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The high-level line number, or 0 if not present
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{location@\verb`location`}
\begin{ocamldocdescription}
Type for source-file locations


\end{ocamldocdescription}




\label{val:Errormsg.d-underscoreloc}\begin{ocamldoccode}
val d_loc : unit -> location -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreloc@\verb`d_loc`}




\label{val:Errormsg.d-underscorehloc}\begin{ocamldoccode}
val d_hloc : unit -> location -> Pretty.doc
\end{ocamldoccode}
\index{d-underscorehloc@\verb`d_hloc`}




\label{val:Errormsg.getLocation}\begin{ocamldoccode}
val getLocation : unit -> location
\end{ocamldoccode}
\index{getLocation@\verb`getLocation`}




\label{val:Errormsg.parse-underscoreerror}\begin{ocamldoccode}
val parse_error : string -> 'a
\end{ocamldoccode}
\index{parse-underscoreerror@\verb`parse_error`}




\label{val:Errormsg.locUnknown}\begin{ocamldoccode}
val locUnknown : location
\end{ocamldoccode}
\index{locUnknown@\verb`locUnknown`}
\begin{ocamldocdescription}
An unknown location for use when you need one but you don't have one


\end{ocamldocdescription}




\label{val:Errormsg.readingFromStdin}\begin{ocamldoccode}
val readingFromStdin : bool ref
\end{ocamldoccode}
\index{readingFromStdin@\verb`readingFromStdin`}
\begin{ocamldocdescription}
Records whether the stdin is open for reading the goal *


\end{ocamldocdescription}




\label{val:Errormsg.startParsing}\begin{ocamldoccode}
val startParsing : ?useBasename:bool -> string -> Lexing.lexbuf
\end{ocamldoccode}
\index{startParsing@\verb`startParsing`}




\label{val:Errormsg.startParsingFromString}\begin{ocamldoccode}
val startParsingFromString :
  ?file:string -> ?line:int -> string -> Lexing.lexbuf
\end{ocamldoccode}
\index{startParsingFromString@\verb`startParsingFromString`}




\label{val:Errormsg.finishParsing}\begin{ocamldoccode}
val finishParsing : unit -> unit
\end{ocamldoccode}
\index{finishParsing@\verb`finishParsing`}


\section{Module {\tt{Clist}} : Utilities for managing "concatenable lists" (clists).}
\label{module:Clist}\index{Clist@\verb`Clist`}
 We often need to
    concatenate sequences, and using lists for this purpose is expensive. This
    module provides routines to manage such lists more efficiently. In this
    model, we never do cons or append explicitly. Instead we maintain
    the elements of the list in a special data structure. Routines are provided
    to convert to/from ordinary lists, and carry out common list operations.



\ocamldocvspace{0.5cm}



\label{type:Clist.clist}\begin{ocamldoccode}
type 'a clist =
  | CList of 'a list
\end{ocamldoccode}
\begin{ocamldoccomment}
The only representation for the empty 
                                     list. Try to use sparingly.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | CConsL of 'a * 'a clist
\end{ocamldoccode}
\begin{ocamldoccomment}
Do not use this a lot because scanning 
 it is not tail recursive
\end{ocamldoccomment}
\begin{ocamldoccode}
  | CConsR of 'a clist * 'a
  | CSeq of 'a clist * 'a clist
\end{ocamldoccode}
\begin{ocamldoccomment}
We concatenate only two of them at this
                                    time. Neither is the empty clist. To be
                                    sure always use append to make these
\end{ocamldoccomment}
\index{clist@\verb`clist`}
\begin{ocamldocdescription}
The clist datatype. A clist can be an ordinary list, or a clist preceded 
    or followed by an element, or two clists implicitly appended together


\end{ocamldocdescription}




\label{val:Clist.toList}\begin{ocamldoccode}
val toList : 'a clist -> 'a list
\end{ocamldoccode}
\index{toList@\verb`toList`}
\begin{ocamldocdescription}
Convert a clist to an ordinary list


\end{ocamldocdescription}




\label{val:Clist.fromList}\begin{ocamldoccode}
val fromList : 'a list -> 'a clist
\end{ocamldoccode}
\index{fromList@\verb`fromList`}
\begin{ocamldocdescription}
Convert an ordinary list to a clist


\end{ocamldocdescription}




\label{val:Clist.single}\begin{ocamldoccode}
val single : 'a -> 'a clist
\end{ocamldoccode}
\index{single@\verb`single`}
\begin{ocamldocdescription}
Create a clist containing one element


\end{ocamldocdescription}




\label{val:Clist.empty}\begin{ocamldoccode}
val empty : 'a clist
\end{ocamldoccode}
\index{empty@\verb`empty`}
\begin{ocamldocdescription}
The empty clist


\end{ocamldocdescription}




\label{val:Clist.append}\begin{ocamldoccode}
val append : 'a clist -> 'a clist -> 'a clist
\end{ocamldoccode}
\index{append@\verb`append`}
\begin{ocamldocdescription}
Append two clists


\end{ocamldocdescription}




\label{val:Clist.checkBeforeAppend}\begin{ocamldoccode}
val checkBeforeAppend : 'a clist -> 'a clist -> bool
\end{ocamldoccode}
\index{checkBeforeAppend@\verb`checkBeforeAppend`}
\begin{ocamldocdescription}
A useful check to assert before an append. It checks that the two lists 
 are not identically the same (Except if they are both empty)


\end{ocamldocdescription}




\label{val:Clist.length}\begin{ocamldoccode}
val length : 'a clist -> int
\end{ocamldoccode}
\index{length@\verb`length`}
\begin{ocamldocdescription}
Find the length of a clist


\end{ocamldocdescription}




\label{val:Clist.map}\begin{ocamldoccode}
val map : ('a -> 'b) -> 'a clist -> 'b clist
\end{ocamldoccode}
\index{map@\verb`map`}
\begin{ocamldocdescription}
Map a function over a clist. Returns another clist


\end{ocamldocdescription}




\label{val:Clist.fold-underscoreleft}\begin{ocamldoccode}
val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b clist -> 'a
\end{ocamldoccode}
\index{fold-underscoreleft@\verb`fold_left`}
\begin{ocamldocdescription}
A version of fold\_left that works on clists


\end{ocamldocdescription}




\label{val:Clist.iter}\begin{ocamldoccode}
val iter : ('a -> unit) -> 'a clist -> unit
\end{ocamldoccode}
\index{iter@\verb`iter`}
\begin{ocamldocdescription}
A version of iter that works on clists


\end{ocamldocdescription}




\label{val:Clist.rev}\begin{ocamldoccode}
val rev : ('a -> 'a) -> 'a clist -> 'a clist
\end{ocamldoccode}
\index{rev@\verb`rev`}
\begin{ocamldocdescription}
Reverse a clist. The first function reverses an element.


\end{ocamldocdescription}




\label{val:Clist.docCList}\begin{ocamldoccode}
val docCList :
  Pretty.doc -> ('a -> Pretty.doc) -> unit -> 'a clist -> Pretty.doc
\end{ocamldoccode}
\index{docCList@\verb`docCList`}
\begin{ocamldocdescription}
A document for printing a clist (similar to {\tt{docList}})


\end{ocamldocdescription}


\section{Module {\tt{Stats}} : Utilities for maintaining timing statistics}
\label{module:Stats}\index{Stats@\verb`Stats`}




\ocamldocvspace{0.5cm}



\label{type:Stats.timerModeEnum}\begin{ocamldoccode}
type timerModeEnum =
  | Disabled
\end{ocamldoccode}
\begin{ocamldoccomment}
Do not collect timing information
\end{ocamldoccomment}
\begin{ocamldoccode}
  | SoftwareTimer
\end{ocamldoccode}
\begin{ocamldoccomment}
Use OCaml's {\tt{Unix.time}} for timing information
\end{ocamldoccomment}
\begin{ocamldoccode}
  | HardwareTimer
\end{ocamldoccode}
\begin{ocamldoccomment}
Use the Pentium's cycle counter to time code
\end{ocamldoccomment}
\begin{ocamldoccode}
  | HardwareIfAvail
\end{ocamldoccode}
\begin{ocamldoccomment}
Use the hardware cycle counter if availible; 
                        otherwise use SoftwareTimer
\end{ocamldoccomment}
\index{timerModeEnum@\verb`timerModeEnum`}
\begin{ocamldocdescription}
Whether to use the performance counters (on Pentium only)


\end{ocamldocdescription}




\label{val:Stats.reset}\begin{ocamldoccode}
val reset : timerModeEnum -> unit
\end{ocamldoccode}
\index{reset@\verb`reset`}
\begin{ocamldocdescription}
Resets all the timings and specifies the method to use for future timings.
  Call this before doing any timing.


 You will get an exception if you pass HardwareTimer to reset and the
 hardware counters are not available


\end{ocamldocdescription}




\label{exception:Stats.NoPerfCount}\begin{ocamldoccode}
exception NoPerfCount
\end{ocamldoccode}
\index{NoPerfCount@\verb`NoPerfCount`}




\label{val:Stats.countCalls}\begin{ocamldoccode}
val countCalls : bool ref
\end{ocamldoccode}
\index{countCalls@\verb`countCalls`}
\begin{ocamldocdescription}
Flag to indicate whether or not to count the number of calls of
    to {\tt{Stats.repeattime}}[\ref{val:Stats.repeattime}] or {\tt{Stats.time}}[\ref{val:Stats.time}] for each label.
    (default: false)


\end{ocamldocdescription}




\label{val:Stats.has-underscoreperformance-underscorecounters}\begin{ocamldoccode}
val has_performance_counters : unit -> bool
\end{ocamldoccode}
\index{has-underscoreperformance-underscorecounters@\verb`has_performance_counters`}
\begin{ocamldocdescription}
Check if we have performance counters


\end{ocamldocdescription}




\label{val:Stats.sample-underscorepentium-underscoreperfcount-underscore20}\begin{ocamldoccode}
val sample_pentium_perfcount_20 : unit -> int
\end{ocamldoccode}
\index{sample-underscorepentium-underscoreperfcount-underscore20@\verb`sample_pentium_perfcount_20`}
\begin{ocamldocdescription}
Sample the current cycle count, in megacycles.


\end{ocamldocdescription}




\label{val:Stats.sample-underscorepentium-underscoreperfcount-underscore10}\begin{ocamldoccode}
val sample_pentium_perfcount_10 : unit -> int
\end{ocamldoccode}
\index{sample-underscorepentium-underscoreperfcount-underscore10@\verb`sample_pentium_perfcount_10`}
\begin{ocamldocdescription}
Sample the current cycle count, in kilocycles.


\end{ocamldocdescription}




\label{val:Stats.time}\begin{ocamldoccode}
val time : string -> ('a -> 'b) -> 'a -> 'b
\end{ocamldoccode}
\index{time@\verb`time`}
\begin{ocamldocdescription}
Time a function and associate the time with the given string. If some
    timing information is already associated with that string, then accumulate
    the times. If this function is invoked within another timed function then
    you can have a hierarchy of timings


\end{ocamldocdescription}




\label{val:Stats.repeattime}\begin{ocamldoccode}
val repeattime : float -> string -> ('a -> 'b) -> 'a -> 'b
\end{ocamldoccode}
\index{repeattime@\verb`repeattime`}
\begin{ocamldocdescription}
repeattime is like time but runs the function several times until the total
    running time is greater or equal to the first argument. The total time is
    then divided by the number of times the function was run.


\end{ocamldocdescription}




\label{val:Stats.print}\begin{ocamldoccode}
val print : out_channel -> string -> unit
\end{ocamldoccode}
\index{print@\verb`print`}
\begin{ocamldocdescription}
Print the current stats preceeded by a message


\end{ocamldocdescription}




\label{val:Stats.lookupTime}\begin{ocamldoccode}
val lookupTime : string -> float
\end{ocamldoccode}
\index{lookupTime@\verb`lookupTime`}
\begin{ocamldocdescription}
Return the cumulative time of all calls to {\tt{Stats.time}}[\ref{val:Stats.time}] and
  {\tt{Stats.repeattime}}[\ref{val:Stats.repeattime}] with the given label.


\end{ocamldocdescription}




\label{val:Stats.timethis}\begin{ocamldoccode}
val timethis : ('a -> 'b) -> 'a -> 'b
\end{ocamldoccode}
\index{timethis@\verb`timethis`}
\begin{ocamldocdescription}
Time a function and set lastTime to the time it took


\end{ocamldocdescription}




\label{val:Stats.lastTime}\begin{ocamldoccode}
val lastTime : float ref
\end{ocamldoccode}
\index{lastTime@\verb`lastTime`}


\section{Module {\tt{Cil}} : {\bf CIL API Documentation.}}
\label{module:Cil}\index{Cil@\verb`Cil`}
{\bf }  An html version of this document 
  can be found at http://hal.cs.berkeley.edu/cil



\ocamldocvspace{0.5cm}



{\bf CIL API Documentation.}  An html version of this document 
  can be found at http://hal.cs.berkeley.edu/cil



\label{val:Cil.initCIL}\begin{ocamldoccode}
val initCIL : unit -> unit
\end{ocamldoccode}
\index{initCIL@\verb`initCIL`}
\begin{ocamldocdescription}
Call this function to perform some initialization. Call if after you have 
 set {\tt{Cil.msvcMode}}[\ref{val:Cil.msvcMode}].


\end{ocamldocdescription}




\label{val:Cil.cilVersion}\begin{ocamldoccode}
val cilVersion : string
\end{ocamldoccode}
\index{cilVersion@\verb`cilVersion`}
\begin{ocamldocdescription}
These are the CIL version numbers. A CIL version is a number of the form 
 M.m.r (major, minor and release)


\end{ocamldocdescription}




\label{val:Cil.cilVersionMajor}\begin{ocamldoccode}
val cilVersionMajor : int
\end{ocamldoccode}
\index{cilVersionMajor@\verb`cilVersionMajor`}




\label{val:Cil.cilVersionMinor}\begin{ocamldoccode}
val cilVersionMinor : int
\end{ocamldoccode}
\index{cilVersionMinor@\verb`cilVersionMinor`}




\label{val:Cil.cilVersionRevision}\begin{ocamldoccode}
val cilVersionRevision : int
\end{ocamldoccode}
\index{cilVersionRevision@\verb`cilVersionRevision`}




This module defines the abstract syntax of CIL. It also provides utility 
 functions for traversing the CIL data structures, and pretty-printing 
 them. The parser for both the GCC and MSVC front-ends can be invoked as 
 {\tt{Frontc.parse: string -> unit ->}} {\tt{Cil.file}}[\ref{type:Cil.file}]. This function must be given 
 the name of a preprocessed C file and will return the top-level data 
 structure that describes a whole source file. By default the parsing and 
 elaboration into CIL is done as for GCC source. If you want to use MSVC 
 source you must set the {\tt{Cil.msvcMode}}[\ref{val:Cil.msvcMode}] to {\tt{true}} and must also invoke the 
 function {\tt{Frontc.setMSVCMode: unit -> unit}}.



{\bf The Abstract Syntax of CIL}



The top-level representation of a CIL source file (and the result of the 
 parsing and elaboration). Its main contents is the list of global 
 declarations and definitions. You can iterate over the globals in a 
 {\tt{Cil.file}}[\ref{type:Cil.file}] using the following iterators: {\tt{Cil.mapGlobals}}[\ref{val:Cil.mapGlobals}], 
 {\tt{Cil.iterGlobals}}[\ref{val:Cil.iterGlobals}] and {\tt{Cil.foldGlobals}}[\ref{val:Cil.foldGlobals}]. You can also use the 
 {\tt{Cil.dummyFile}}[\ref{val:Cil.dummyFile}] when you need a {\tt{Cil.file}}[\ref{type:Cil.file}] as a placeholder. For each 
 global item CIL stores the source location where it appears (using the 
 type {\tt{Cil.location}}[\ref{type:Cil.location}])



\label{type:Cil.file}\begin{ocamldoccode}
type file = \{
  mutable fileName : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The complete file name
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable globals : global list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
List of globals as they will appear 
                                        in the printed file
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable globinit : fundec option ;
\end{ocamldoccode}
\begin{ocamldoccomment}
An optional global initializer function. This is a function where 
 you can put stuff that must be executed before the program is 
 started. This function is conceptually at the end of the file, 
 although it is not part of the globals list. Use {\tt{Cil.getGlobInit}}[\ref{val:Cil.getGlobInit}] 
 to create/get one.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable globinitcalled : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Whether the global initialization function is called in main. This 
 should always be false if there is no global initializer. When you 
 create a global initialization CIL will try to insert code in main 
 to call it. This will not happen if your file does not contain a 
 function called "main"
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{file@\verb`file`}
\begin{ocamldocdescription}
Top-level representation of a C source file


\end{ocamldocdescription}




\label{type:Cil.comment}\begin{ocamldoccode}
type comment = location * string 
\end{ocamldoccode}
\index{comment@\verb`comment`}




{\bf Globals}. The main type for representing global declarations and 
 definitions. A list of these form a CIL file. The order of globals in the 
 file is generally important.



\label{type:Cil.global}\begin{ocamldoccode}
type global =
  | GType of typeinfo * location
\end{ocamldoccode}
\begin{ocamldoccomment}
A typedef. All uses of type names (through the {\tt{TNamed}} constructor) 
        must be preceded in the file by a definition of the name. The string 
        is the defined name and always not-empty.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GCompTag of compinfo * location
\end{ocamldoccode}
\begin{ocamldoccomment}
Defines a struct/union tag with some fields. There must be one of 
        these for each struct/union tag that you use (through the {\tt{TComp}} 
        constructor) since this is the only context in which the fields are 
        printed. Consequently nested structure tag definitions must be 
        broken into individual definitions with the innermost structure 
        defined first.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GCompTagDecl of compinfo * location
\end{ocamldoccode}
\begin{ocamldoccomment}
Declares a struct/union tag. Use as a forward declaration. This is 
 printed without the fields.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GEnumTag of enuminfo * location
\end{ocamldoccode}
\begin{ocamldoccomment}
Declares an enumeration tag with some fields. There must be one of 
      these for each enumeration tag that you use (through the {\tt{TEnum}} 
      constructor) since this is the only context in which the items are 
      printed.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GEnumTagDecl of enuminfo * location
\end{ocamldoccode}
\begin{ocamldoccomment}
Declares an enumeration tag. Use as a forward declaration. This is 
 printed without the items.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GVarDecl of varinfo * location
\end{ocamldoccode}
\begin{ocamldoccomment}
A variable declaration (not a definition). If the variable has a 
       function type then this is a prototype. There can be several 
       declarations and at most one definition for a given variable. If both 
       forms appear then they must share the same varinfo structure. A 
       prototype shares the varinfo with the fundec of the definition. Either 
       has storage Extern or there must be a definition in this file
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GVar of varinfo * initinfo * location
\end{ocamldoccode}
\begin{ocamldoccomment}
A variable definition. Can have an initializer. The initializer is 
 updateable so that you can change it without requiring to recreate 
 the list of globals. There can be at most one definition for a 
 variable in an entire program. Cannot have storage Extern or function 
 type.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GFun of fundec * location
\end{ocamldoccode}
\begin{ocamldoccomment}
A function definition.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GAsm of string * location
\end{ocamldoccode}
\begin{ocamldoccomment}
Global asm statement. These ones 
                                            can contain only a template
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GPragma of attribute * location
\end{ocamldoccode}
\begin{ocamldoccomment}
Pragmas at top level. Use the same 
                                            syntax as attributes
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GText of string
\end{ocamldoccode}
\begin{ocamldoccomment}
Some text (printed verbatim) at 
                                            top level. E.g., this way you can 
                                            put comments in the output.
\end{ocamldoccomment}
\index{global@\verb`global`}
\begin{ocamldocdescription}
A global declaration or definition


\end{ocamldocdescription}




{\bf Types}. A C type is represented in CIL using the type {\tt{Cil.typ}}[\ref{type:Cil.typ}]. 
 Among types we differentiate the integral types (with different kinds 
 denoting the sign and precision), floating point types, enumeration types, 
 array and pointer types, and function types. Every type is associated with 
 a list of attributes, which are always kept in sorted order. Use 
 {\tt{Cil.addAttribute}}[\ref{val:Cil.addAttribute}] and {\tt{Cil.addAttributes}}[\ref{val:Cil.addAttributes}] to construct list of 
 attributes. If you want to inspect a type, you should use 
 {\tt{Cil.unrollType}}[\ref{val:Cil.unrollType}] or {\tt{Cil.unrollTypeDeep}}[\ref{val:Cil.unrollTypeDeep}] to see through the uses of 
 named types.



CIL is configured at build-time with the sizes and alignments of the 
 underlying compiler (GCC or MSVC). CIL contains functions that can compute 
 the size of a type (in bits) {\tt{Cil.bitsSizeOf}}[\ref{val:Cil.bitsSizeOf}], the alignment of a type 
 (in bytes) {\tt{Cil.alignOf\_int}}[\ref{val:Cil.alignOf-underscoreint}], and can convert an offset into a start and 
 width (both in bits) using the function {\tt{Cil.bitsOffset}}[\ref{val:Cil.bitsOffset}]. At the moment 
 these functions do not take into account the {\tt{packed}} attributes and 
 pragmas.



\label{type:Cil.typ}\begin{ocamldoccode}
type typ =
  | TVoid of attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
Void type. Also predefined as {\tt{Cil.voidType}}[\ref{val:Cil.voidType}]
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TInt of ikind * attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
An integer type. The kind specifies the sign and width. Several 
 useful variants are predefined as {\tt{Cil.intType}}[\ref{val:Cil.intType}], {\tt{Cil.uintType}}[\ref{val:Cil.uintType}], 
 {\tt{Cil.longType}}[\ref{val:Cil.longType}], {\tt{Cil.charType}}[\ref{val:Cil.charType}].
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TFloat of fkind * attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
A floating-point type. The kind specifies the precision. You can 
 also use the predefined constant {\tt{Cil.doubleType}}[\ref{val:Cil.doubleType}].
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TPtr of typ * attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
Pointer type. Several useful variants are predefined as 
 {\tt{Cil.charPtrType}}[\ref{val:Cil.charPtrType}], {\tt{Cil.charConstPtrType}}[\ref{val:Cil.charConstPtrType}] (pointer to a 
 constant character), {\tt{Cil.voidPtrType}}[\ref{val:Cil.voidPtrType}], 
 {\tt{Cil.intPtrType}}[\ref{val:Cil.intPtrType}]
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TArray of typ * exp option * attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
Array type. It indicates the base type and the array length.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TFun of typ * (string * typ * attributes) list option * bool
   * attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
Function type. Indicates the type of the result, the name, type 
 and name attributes of the formal arguments ({\tt{None}} if no 
 arguments were specified, as in a function whose definition or 
 prototype we have not seen; {\tt{Some []}} means void). Use 
 {\tt{Cil.argsToList}}[\ref{val:Cil.argsToList}] to obtain a list of arguments. The boolean 
 indicates if it is a variable-argument function. If this is the 
 type of a varinfo for which we have a function declaration then 
 the information for the formals must match that in the 
 function's sformals. Use {\tt{Cil.setFormals}}[\ref{val:Cil.setFormals}], or 
 {\tt{Cil.setFunctionType}}[\ref{val:Cil.setFunctionType}], or {\tt{Cil.makeFormalVar}}[\ref{val:Cil.makeFormalVar}] for this 
 purpose.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TNamed of typeinfo * attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
The use of a named type. Each such type name must be preceded 
 in the file by a {\tt{GType}} global. This is printed as just the 
 type name. The actual referred type is not printed here and is 
 carried only to simplify processing. To see through a sequence 
 of named type references, use {\tt{Cil.unrollType}}[\ref{val:Cil.unrollType}] or 
 {\tt{Cil.unrollTypeDeep}}[\ref{val:Cil.unrollTypeDeep}]. The attributes are in addition to those 
 given when the type name was defined.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TComp of compinfo * attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
The most delicate issue for C types is that recursion that is possible by 
 using structures and pointers. To address this issue we have a more 
 complex representation for structured types (struct and union). Each such 
 type is represented using the {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}] type. For each composite 
 type the {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}] structure must be declared at top level using 
 {\tt{GCompTag}} and all references to it must share the same copy of the 
 structure. The attributes given are those pertaining to this use of the 
 type and are in addition to the attributes that were given at the 
 definition of the type and which are stored in the {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}].
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TEnum of enuminfo * attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
A reference to an enumeration type. All such references must
               share the enuminfo among them and with a {\tt{GEnumTag}} global that 
               precedes all uses. The attributes refer to this use of the 
               enumeration and are in addition to the attributes of the 
               enumeration itself, which are stored inside the enuminfo
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TBuiltin_va_list of attributes
\end{ocamldoccode}
\begin{ocamldoccomment}
This is the same as the gcc's type with the same name
\end{ocamldoccomment}
\index{typ@\verb`typ`}




There are a number of functions for querying the kind of a type. These are
 {\tt{Cil.isIntegralType}}[\ref{val:Cil.isIntegralType}], 
 {\tt{Cil.isArithmeticType}}[\ref{val:Cil.isArithmeticType}], 
 {\tt{Cil.isPointerType}}[\ref{val:Cil.isPointerType}], 
 {\tt{Cil.isScalarType}}[\ref{val:Cil.isScalarType}], 
 {\tt{Cil.isFunctionType}}[\ref{val:Cil.isFunctionType}], 
 {\tt{Cil.isArrayType}}[\ref{val:Cil.isArrayType}]. 


 There are two easy ways to scan a type. First, you can use the
{\tt{Cil.existsType}}[\ref{val:Cil.existsType}] to return a boolean answer about a type. This function
is controlled by a user-provided function that is queried for each type that is
used to construct the current type. The function can specify whether to
terminate the scan with a boolean result or to continue the scan for the
nested types. 


 The other method for scanning types is provided by the visitor interface (see
 {\tt{Cil.cilVisitor}}[\ref{classtype:Cil.cilVisitor}]).


 If you want to compare types (or to use them as hash-values) then you should
use instead type signatures (represented as {\tt{Cil.typsig}}[\ref{type:Cil.typsig}]). These
contain the same information as types but canonicalized such that simple Ocaml
structural equality will tell whether two types are equal. Use
{\tt{Cil.typeSig}}[\ref{val:Cil.typeSig}] to compute the signature of a type. If you want to ignore
certain type attributes then use {\tt{Cil.typeSigWithAttrs}}[\ref{val:Cil.typeSigWithAttrs}].



\label{type:Cil.ikind}\begin{ocamldoccode}
type ikind =
  | IChar
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{char}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ISChar
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{signed char}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | IUChar
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{unsigned char}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | IBool
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{\_Bool (C99)}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | IInt
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{int}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | IUInt
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{unsigned int}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | IShort
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{short}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | IUShort
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{unsigned short}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ILong
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{long}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | IULong
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{unsigned long}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ILongLong
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{long long}} (or {\tt{\_int64}} on Microsoft Visual C)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | IULongLong
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{unsigned long long}} (or {\tt{unsigned \_int64}} on Microsoft 
                    Visual C)
\end{ocamldoccomment}
\index{ikind@\verb`ikind`}
\begin{ocamldocdescription}
Various kinds of integers


\end{ocamldocdescription}




\label{type:Cil.fkind}\begin{ocamldoccode}
type fkind =
  | FFloat
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{float}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | FDouble
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{double}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | FLongDouble
\end{ocamldoccode}
\begin{ocamldoccomment}
{\tt{long double}}
\end{ocamldoccomment}
\index{fkind@\verb`fkind`}
\begin{ocamldocdescription}
Various kinds of floating-point numbers


\end{ocamldocdescription}




{\bf Attributes.}



\label{type:Cil.attribute}\begin{ocamldoccode}
type attribute =
  | Attr of string * attrparam list
\end{ocamldoccode}
\begin{ocamldoccomment}
An attribute has a name and some optional parameters. The name should not 
 start or end with underscore. When CIL parses attribute names it will 
 strip leading and ending underscores (to ensure that the multitude of GCC 
 attributes such as const, \_\_const and \_\_const\_\_ all mean the same thing.)
\end{ocamldoccomment}
\index{attribute@\verb`attribute`}




\label{type:Cil.attributes}\begin{ocamldoccode}
type attributes = attribute list 
\end{ocamldoccode}
\index{attributes@\verb`attributes`}
\begin{ocamldocdescription}
Attributes are lists sorted by the attribute name. Use the functions 
 {\tt{Cil.addAttribute}}[\ref{val:Cil.addAttribute}] and {\tt{Cil.addAttributes}}[\ref{val:Cil.addAttributes}] to insert attributes in an 
 attribute list and maintain the sortedness.


\end{ocamldocdescription}




\label{type:Cil.attrparam}\begin{ocamldoccode}
type attrparam =
  | AInt of int
\end{ocamldoccode}
\begin{ocamldoccomment}
An integer constant
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AStr of string
\end{ocamldoccode}
\begin{ocamldoccomment}
A string constant
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ACons of string * attrparam list
\end{ocamldoccode}
\begin{ocamldoccomment}
Constructed attributes. These 
                                             are printed {\tt{foo(a1,a2,...,an)}}. 
                                             The list of parameters can be 
                                             empty and in that case the 
                                             parentheses are not printed.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ASizeOf of typ
\end{ocamldoccode}
\begin{ocamldoccomment}
A way to talk about types
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ASizeOfE of attrparam
  | ASizeOfS of typsig
\end{ocamldoccode}
\begin{ocamldoccomment}
Replacement for ASizeOf in type
                                             signatures.  Only used for
                                             attributes inside typsigs.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AAlignOf of typ
  | AAlignOfE of attrparam
  | AAlignOfS of typsig
  | AUnOp of unop * attrparam
  | ABinOp of binop * attrparam * attrparam
  | ADot of attrparam * string
\end{ocamldoccode}
\begin{ocamldoccomment}
a.foo *
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AStar of attrparam
\end{ocamldoccode}
\begin{ocamldoccomment}
 a
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AAddrOf of attrparam
\end{ocamldoccode}
\begin{ocamldoccomment}
\& a *
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AIndex of attrparam * attrparam
\end{ocamldoccode}
\begin{ocamldoccomment}
a1{\tt{a2}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AQuestion of attrparam * attrparam * attrparam
\end{ocamldoccode}
\begin{ocamldoccomment}
a1 ? a2 : a3 *
\end{ocamldoccomment}
\index{attrparam@\verb`attrparam`}
\begin{ocamldocdescription}
The type of parameters of attributes


\end{ocamldocdescription}




{\bf Structures.} The {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}] describes the definition of a 
 structure or union type. Each such {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}] must be defined at the 
 top-level using the {\tt{GCompTag}} constructor and must be shared by all 
 references to this type (using either the {\tt{TComp}} type constructor or from 
 the definition of the fields. 


   If all you need is to scan the definition of each 
 composite type once, you can do that by scanning all top-level {\tt{GCompTag}}. 


 Constructing a {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}] can be tricky since it must contain fields 
 that might refer to the host {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}] and furthermore the type of 
 the field might need to refer to the {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}] for recursive types. 
 Use the {\tt{Cil.mkCompInfo}}[\ref{val:Cil.mkCompInfo}] function to create a {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}]. You can 
 easily fetch the {\tt{Cil.fieldinfo}}[\ref{type:Cil.fieldinfo}] for a given field in a structure with 
 {\tt{Cil.getCompField}}[\ref{val:Cil.getCompField}].



\label{type:Cil.compinfo}\begin{ocamldoccode}
type compinfo = \{
  mutable cstruct : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
True if struct, False if union
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable cname : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The name. Always non-empty. Use {\tt{Cil.compFullName}}[\ref{val:Cil.compFullName}] to get the full 
 name of a comp (along with the struct or union)
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable ckey : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
A unique integer. This is assigned by {\tt{Cil.mkCompInfo}}[\ref{val:Cil.mkCompInfo}] using a 
 global variable in the Cil module. Thus two identical structs in two 
 different files might have different keys. Use {\tt{Cil.copyCompInfo}}[\ref{val:Cil.copyCompInfo}] to 
 copy structures so that a new key is assigned.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable cfields : fieldinfo list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Information about the fields. Notice that each fieldinfo has a 
 pointer back to the host compinfo. This means that you should not 
 share fieldinfo's between two compinfo's
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable cattr : attributes ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The attributes that are defined at the same time as the composite 
 type. These attributes can be supplemented individually at each 
 reference to this {\tt{compinfo}} using the {\tt{TComp}} type constructor.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable cdefined : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
This boolean flag can be used to distinguish between structures
     that have not been defined and those that have been defined but have
     no fields (such things are allowed in gcc).
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable creferenced : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
True if used. Initially set to false.
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{compinfo@\verb`compinfo`}
\begin{ocamldocdescription}
The definition of a structure or union type. Use {\tt{Cil.mkCompInfo}}[\ref{val:Cil.mkCompInfo}] to 
 make one and use {\tt{Cil.copyCompInfo}}[\ref{val:Cil.copyCompInfo}] to copy one (this ensures that a new 
 key is assigned and that the fields have the right pointers to parents.).


\end{ocamldocdescription}




{\bf Structure fields.} The {\tt{Cil.fieldinfo}}[\ref{type:Cil.fieldinfo}] structure is used to describe 
 a structure or union field. Fields, just like variables, can have 
 attributes associated with the field itself or associated with the type of 
 the field (stored along with the type of the field).



\label{type:Cil.fieldinfo}\begin{ocamldoccode}
type fieldinfo = \{
  mutable fcomp : compinfo ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The host structure that contains this field. There can be only one 
 {\tt{compinfo}} that contains the field.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable fname : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The name of the field. Might be the value of {\tt{Cil.missingFieldName}}[\ref{val:Cil.missingFieldName}] 
 in which case it must be a bitfield and is not printed and it does not 
 participate in initialization
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable ftype : typ ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The type
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable fbitfield : int option ;
\end{ocamldoccode}
\begin{ocamldoccomment}
If a bitfield then ftype should be an integer type and the width of 
 the bitfield must be 0 or a positive integer smaller or equal to the 
 width of the integer type. A field of width 0 is used in C to control 
 the alignment of fields.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable fattr : attributes ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The attributes for this field (not for its type)
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable floc : location ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The location where this field is defined
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{fieldinfo@\verb`fieldinfo`}
\begin{ocamldocdescription}
Information about a struct/union field


\end{ocamldocdescription}




{\bf Enumerations.} Information about an enumeration. This is shared by all 
 references to an enumeration. Make sure you have a {\tt{GEnumTag}} for each of 
 of these.



\label{type:Cil.enuminfo}\begin{ocamldoccode}
type enuminfo = \{
  mutable ename : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The name. Always non-empty.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable eitems : (string * exp * location) list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Items with names and values. This list should be non-empty. The item 
 values must be compile-time constants.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable eattr : attributes ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The attributes that are defined at the same time as the enumeration 
 type. These attributes can be supplemented individually at each 
 reference to this {\tt{enuminfo}} using the {\tt{TEnum}} type constructor.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable ereferenced : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
True if used. Initially set to false
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable ekind : ikind ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The integer kind used to represent this enum. Per ANSI-C, this
 should always be IInt, but gcc allows other integer kinds
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{enuminfo@\verb`enuminfo`}
\begin{ocamldocdescription}
Information about an enumeration


\end{ocamldocdescription}




{\bf Enumerations.} Information about an enumeration. This is shared by all 
 references to an enumeration. Make sure you have a {\tt{GEnumTag}} for each of 
 of these.



\label{type:Cil.typeinfo}\begin{ocamldoccode}
type typeinfo = \{
  mutable tname : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The name. Can be empty only in a {\tt{GType}} when introducing a composite 
 or enumeration tag. If empty cannot be referred to from the file
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable ttype : typ ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The actual type. This includes the attributes that were present in 
 the typedef
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable treferenced : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
True if used. Initially set to false
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{typeinfo@\verb`typeinfo`}
\begin{ocamldocdescription}
Information about a defined type


\end{ocamldocdescription}




{\bf Variables.} 
 Each local or global variable is represented by a unique {\tt{Cil.varinfo}}[\ref{type:Cil.varinfo}]
structure. A global {\tt{Cil.varinfo}}[\ref{type:Cil.varinfo}] can be introduced with the {\tt{GVarDecl}} or
{\tt{GVar}} or {\tt{GFun}} globals. A local varinfo can be introduced as part of a
function definition {\tt{Cil.fundec}}[\ref{type:Cil.fundec}]. 


 All references to a given global or local variable must refer to the same
copy of the {\tt{varinfo}}. Each {\tt{varinfo}} has a globally unique identifier that 
can be used to index maps and hashtables (the name can also be used for this 
purpose, except for locals from different functions). This identifier is 
constructor using a global counter.


 It is very important that you construct {\tt{varinfo}} structures using only one
 of the following functions:\begin{itemize}
\item {\tt{Cil.makeGlobalVar}}[\ref{val:Cil.makeGlobalVar}] : to make a global variable
\item {\tt{Cil.makeTempVar}}[\ref{val:Cil.makeTempVar}] : to make a temporary local variable whose name
will be generated so that to avoid conflict with other locals. 
\item {\tt{Cil.makeLocalVar}}[\ref{val:Cil.makeLocalVar}] : like {\tt{Cil.makeTempVar}}[\ref{val:Cil.makeTempVar}] but you can specify the
exact name to be used. 
\item {\tt{Cil.copyVarinfo}}[\ref{val:Cil.copyVarinfo}]: make a shallow copy of a varinfo assigning a new name 
and a new unique identifier
\end{itemize}

 A {\tt{varinfo}} is also used in a function type to denote the list of formals.



\label{type:Cil.varinfo}\begin{ocamldoccode}
type varinfo = \{
  mutable vname : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The name of the variable. Cannot be empty. It is primarily your 
 responsibility to ensure the uniqueness of a variable name. For local 
 variables {\tt{Cil.makeTempVar}}[\ref{val:Cil.makeTempVar}] helps you ensure that the name is unique.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vtype : typ ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The declared type of the variable.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vattr : attributes ;
\end{ocamldoccode}
\begin{ocamldoccomment}
A list of attributes associated with the variable.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vstorage : storage ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The storage-class
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vglob : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
True if this is a global variable
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vinline : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Whether this varinfo is for an inline function.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vdecl : location ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Location of variable declaration.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vid : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
A unique integer identifier. This field will be 
 set for you if you use one of the {\tt{Cil.makeFormalVar}}[\ref{val:Cil.makeFormalVar}], 
 {\tt{Cil.makeLocalVar}}[\ref{val:Cil.makeLocalVar}], {\tt{Cil.makeTempVar}}[\ref{val:Cil.makeTempVar}], {\tt{Cil.makeGlobalVar}}[\ref{val:Cil.makeGlobalVar}], or 
 {\tt{Cil.copyVarinfo}}[\ref{val:Cil.copyVarinfo}].
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vaddrof : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
True if the address of this variable is taken. CIL will set these 
 flags when it parses C, but you should make sure to set the flag 
 whenever your transformation create {\tt{AddrOf}} expression.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vreferenced : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
True if this variable is ever referenced. This is computed by 
 {\tt{Rmtmps.removeUnusedTemps}}. It is safe to just initialize this to False
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vdescr : Pretty.doc ;
\end{ocamldoccode}
\begin{ocamldoccomment}
For most temporary variables, a description of what the var holds.
  (e.g. for temporaries used for function call results, this string
   is a representation of the function call.)
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable vdescrpure : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Indicates whether the vdescr above is a pure expression or call.
  Printing a non-pure vdescr more than once may yield incorrect
  results.
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{varinfo@\verb`varinfo`}
\begin{ocamldocdescription}
Information about a variable.


\end{ocamldocdescription}




\label{type:Cil.storage}\begin{ocamldoccode}
type storage =
  | NoStorage
\end{ocamldoccode}
\begin{ocamldoccomment}
The default storage. Nothing is printed
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Static
  | Register
  | Extern
\end{ocamldoccode}
\index{storage@\verb`storage`}
\begin{ocamldocdescription}
Storage-class information


\end{ocamldocdescription}




{\bf Expressions.} The CIL expression language contains only the side-effect free expressions of
C. They are represented as the type {\tt{Cil.exp}}[\ref{type:Cil.exp}]. There are several
interesting aspects of CIL expressions: 


 Integer and floating point constants can carry their textual representation.
This way the integer 15 can be printed as 0xF if that is how it occurred in the
source. 


 CIL uses 64 bits to represent the integer constants and also stores the width
of the integer type. Care must be taken to ensure that the constant is
representable with the given width. Use the functions {\tt{Cil.kinteger}}[\ref{val:Cil.kinteger}],
{\tt{Cil.kinteger64}}[\ref{val:Cil.kinteger64}] and {\tt{Cil.integer}}[\ref{val:Cil.integer}] to construct constant
expressions. CIL predefines the constants {\tt{Cil.zero}}[\ref{val:Cil.zero}],
{\tt{Cil.one}}[\ref{val:Cil.one}] and {\tt{Cil.mone}}[\ref{val:Cil.mone}] (for -1). 


 Use the functions {\tt{Cil.isConstant}}[\ref{val:Cil.isConstant}] and {\tt{Cil.isInteger}}[\ref{val:Cil.isInteger}] to test if
an expression is a constant and a constant integer respectively.


 CIL keeps the type of all unary and binary expressions. You can think of that
type qualifying the operator. Furthermore there are different operators for
arithmetic and comparisons on arithmetic types and on pointers. 


 Another unusual aspect of CIL is that the implicit conversion between an
expression of array type and one of pointer type is made explicit, using the
{\tt{StartOf}} expression constructor (which is not printed). If you apply the
{\tt{AddrOf\}}}constructor to an lvalue of type {\tt{T}} then you will be getting an
expression of type {\tt{TPtr(T)}}.


 You can find the type of an expression with {\tt{Cil.typeOf}}[\ref{val:Cil.typeOf}]. 


 You can perform constant folding on expressions using the function
{\tt{Cil.constFold}}[\ref{val:Cil.constFold}].



\label{type:Cil.exp}\begin{ocamldoccode}
type exp =
  | Const of constant
\end{ocamldoccode}
\begin{ocamldoccomment}
Constant
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Lval of lval
\end{ocamldoccode}
\begin{ocamldoccomment}
Lvalue
\end{ocamldoccomment}
\begin{ocamldoccode}
  | SizeOf of typ
\end{ocamldoccode}
\begin{ocamldoccomment}
sizeof($<$type$>$). Has {\tt{unsigned int}} type (ISO 6.5.3.4). This is not 
 turned into a constant because some transformations might want to 
 change types
\end{ocamldoccomment}
\begin{ocamldoccode}
  | SizeOfE of exp
\end{ocamldoccode}
\begin{ocamldoccomment}
sizeof($<$expression$>$)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | SizeOfStr of string
\end{ocamldoccode}
\begin{ocamldoccomment}
sizeof(string\_literal). We separate this case out because this is the 
 only instance in which a string literal should not be treated as 
 having type pointer to character.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AlignOf of typ
\end{ocamldoccode}
\begin{ocamldoccomment}
This corresponds to the GCC \_\_alignof\_. Has {\tt{unsigned int}} type
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AlignOfE of exp
  | UnOp of unop * exp * typ
\end{ocamldoccode}
\begin{ocamldoccomment}
Unary operation. Includes the type of the result.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | BinOp of binop * exp * exp * typ
\end{ocamldoccode}
\begin{ocamldoccomment}
Binary operation. Includes the type of the result. The arithmetic 
 conversions are made explicit for the arguments.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | CastE of typ * exp
\end{ocamldoccode}
\begin{ocamldoccomment}
Use {\tt{Cil.mkCast}}[\ref{val:Cil.mkCast}] to make casts.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AddrOf of lval
\end{ocamldoccode}
\begin{ocamldoccomment}
Always use {\tt{Cil.mkAddrOf}}[\ref{val:Cil.mkAddrOf}] to construct one of these. Apply to an 
 lvalue of type {\tt{T}} yields an expression of type {\tt{TPtr(T)}}. Use 
 {\tt{Cil.mkAddrOrStartOf}}[\ref{val:Cil.mkAddrOrStartOf}] to make one of these if you are not sure which 
 one to use.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | StartOf of lval
\end{ocamldoccode}
\begin{ocamldoccomment}
Conversion from an array to a pointer to the beginning of the array. 
 Given an lval of type {\tt{TArray(T)}} produces an expression of type 
 {\tt{TPtr(T)}}. Use {\tt{Cil.mkAddrOrStartOf}}[\ref{val:Cil.mkAddrOrStartOf}] to make one of these if you are 
 not sure which one to use. In C this operation is implicit, the 
 {\tt{StartOf}} operator is not printed. We have it in CIL because it makes 
 the typing rules simpler.
\end{ocamldoccomment}
\index{exp@\verb`exp`}
\begin{ocamldocdescription}
Expressions (Side-effect free)


\end{ocamldocdescription}




{\bf Constants.}



\label{type:Cil.constant}\begin{ocamldoccode}
type constant =
  | CInt64 of int64 * ikind * string option
\end{ocamldoccode}
\begin{ocamldoccomment}
Integer constant. Give the ikind (see ISO9899 6.1.3.2) and the 
 textual representation, if available. (This allows us to print a 
 constant as, for example, 0xF instead of 15.) Use {\tt{Cil.integer}}[\ref{val:Cil.integer}] or 
 {\tt{Cil.kinteger}}[\ref{val:Cil.kinteger}] to create these. Watch out for integers that cannot be 
 represented on 64 bits. OCAML does not give Overflow exceptions.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | CStr of string
\end{ocamldoccode}
\begin{ocamldoccomment}
String constant. The escape characters inside the string have been 
 already interpreted. This constant has pointer to character type! The 
 only case when you would like a string literal to have an array type 
 is when it is an argument to sizeof. In that case you should use 
 SizeOfStr.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | CWStr of int64 list
\end{ocamldoccode}
\begin{ocamldoccomment}
Wide character string constant. Note that the local interpretation
 of such a literal depends on {\tt{Cil.wcharType}}[\ref{val:Cil.wcharType}] and {\tt{Cil.wcharKind}}[\ref{val:Cil.wcharKind}].
 Such a constant has type pointer to {\tt{Cil.wcharType}}[\ref{val:Cil.wcharType}]. The
 escape characters in the string have not been "interpreted" in 
 the sense that L"A{\textbackslash}xabcd" remains "A{\textbackslash}xabcd" rather than being
 represented as the wide character list with two elements: 65 and
 43981. That "interpretation" depends on the underlying wide
 character type.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | CChr of char
\end{ocamldoccode}
\begin{ocamldoccomment}
Character constant.  This has type int, so use charConstToInt
 to read the value in case sign-extension is needed.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | CReal of float * fkind * string option
\end{ocamldoccode}
\begin{ocamldoccomment}
Floating point constant. Give the fkind (see ISO 6.4.4.2) and also 
 the textual representation, if available.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | CEnum of exp * string * enuminfo
\end{ocamldoccode}
\begin{ocamldoccomment}
An enumeration constant with the given value, name, from the given 
 enuminfo. This is used only if {\tt{Cil.lowerConstants}}[\ref{val:Cil.lowerConstants}] is true 
 (default). Use {\tt{Cil.constFoldVisitor}}[\ref{val:Cil.constFoldVisitor}] to replace these with integer 
 constants.
\end{ocamldoccomment}
\index{constant@\verb`constant`}
\begin{ocamldocdescription}
Literal constants


\end{ocamldocdescription}




\label{type:Cil.unop}\begin{ocamldoccode}
type unop =
  | Neg
\end{ocamldoccode}
\begin{ocamldoccomment}
Unary minus
\end{ocamldoccomment}
\begin{ocamldoccode}
  | BNot
\end{ocamldoccode}
\begin{ocamldoccomment}
Bitwise complement (\~{})
\end{ocamldoccomment}
\begin{ocamldoccode}
  | LNot
\end{ocamldoccode}
\begin{ocamldoccomment}
Logical Not (!)
\end{ocamldoccomment}
\index{unop@\verb`unop`}
\begin{ocamldocdescription}
Unary operators


\end{ocamldocdescription}




\label{type:Cil.binop}\begin{ocamldoccode}
type binop =
  | PlusA
\end{ocamldoccode}
\begin{ocamldoccomment}
arithmetic +
\end{ocamldoccomment}
\begin{ocamldoccode}
  | PlusPI
\end{ocamldoccode}
\begin{ocamldoccomment}
pointer + integer
\end{ocamldoccomment}
\begin{ocamldoccode}
  | IndexPI
\end{ocamldoccode}
\begin{ocamldoccomment}
pointer + integer but only when 
 it arises from an expression 
 {\tt{e[i]}} when {\tt{e}} is a pointer and 
 not an array. This is semantically 
 the same as PlusPI but CCured uses 
 this as a hint that the integer is 
 probably positive.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | MinusA
\end{ocamldoccode}
\begin{ocamldoccomment}
arithmetic -
\end{ocamldoccomment}
\begin{ocamldoccode}
  | MinusPI
\end{ocamldoccode}
\begin{ocamldoccomment}
pointer - integer
\end{ocamldoccomment}
\begin{ocamldoccode}
  | MinusPP
\end{ocamldoccode}
\begin{ocamldoccomment}
pointer - pointer
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Mult
  | Div
\end{ocamldoccode}
\begin{ocamldoccomment}
/
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Mod
\end{ocamldoccode}
\begin{ocamldoccomment}
\%
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Shiftlt
\end{ocamldoccode}
\begin{ocamldoccomment}
shift left
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Shiftrt
\end{ocamldoccode}
\begin{ocamldoccomment}
shift right
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Lt
\end{ocamldoccode}
\begin{ocamldoccomment}
$<$  (arithmetic comparison)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Gt
\end{ocamldoccode}
\begin{ocamldoccomment}
$>$  (arithmetic comparison)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Le
\end{ocamldoccode}
\begin{ocamldoccomment}
$\leq$ (arithmetic comparison)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Ge
\end{ocamldoccode}
\begin{ocamldoccomment}
$>$  (arithmetic comparison)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Eq
\end{ocamldoccode}
\begin{ocamldoccomment}
$=$$=$ (arithmetic comparison)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Ne
\end{ocamldoccode}
\begin{ocamldoccomment}
!$=$ (arithmetic comparison)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | BAnd
\end{ocamldoccode}
\begin{ocamldoccomment}
bitwise and
\end{ocamldoccomment}
\begin{ocamldoccode}
  | BXor
\end{ocamldoccode}
\begin{ocamldoccomment}
exclusive-or
\end{ocamldoccomment}
\begin{ocamldoccode}
  | BOr
\end{ocamldoccode}
\begin{ocamldoccomment}
inclusive-or
\end{ocamldoccomment}
\begin{ocamldoccode}
  | LAnd
\end{ocamldoccode}
\begin{ocamldoccomment}
logical and. Unlike other 
 expressions this one does not 
 always evaluate both operands. If 
 you want to use these, you must 
 set {\tt{Cil.useLogicalOperators}}[\ref{val:Cil.useLogicalOperators}].
\end{ocamldoccomment}
\begin{ocamldoccode}
  | LOr
\end{ocamldoccode}
\begin{ocamldoccomment}
logical or. Unlike other 
 expressions this one does not 
 always evaluate both operands.  If 
 you want to use these, you must 
 set {\tt{Cil.useLogicalOperators}}[\ref{val:Cil.useLogicalOperators}].
\end{ocamldoccomment}
\index{binop@\verb`binop`}
\begin{ocamldocdescription}
Binary operations


\end{ocamldocdescription}




{\bf Lvalues.} Lvalues are the sublanguage of expressions that can appear at the left of an assignment or as operand to the address-of operator. 
In C the syntax for lvalues is not always a good indication of the meaning 
of the lvalue. For example the C value
\begin{verbatim} 
a[0][1][2]
\end{verbatim}
 might involve 1, 2 or 3 memory reads when used in an expression context,
depending on the declared type of the variable {\tt{a}}. If {\tt{a}} has type {\tt{int\
[4][4][4]}} then we have one memory read from somewhere inside the area 
that stores the array {\tt{a}}. On the other hand if {\tt{a}} has type {\tt{int ***}} then
the expression really means {\tt{* ( * ( * (a + 0) + 1) + 2)}}, in which case it is
clear that it involves three separate memory operations. 


An lvalue denotes the contents of a range of memory addresses. This range 
is denoted as a host object along with an offset within the object. The 
host object can be of two kinds: a local or global variable, or an object 
whose address is in a pointer expression. We distinguish the two cases so 
that we can tell quickly whether we are accessing some component of a 
variable directly or we are accessing a memory location through a pointer.
To make it easy to 
tell what an lvalue means CIL represents lvalues as a host object and an
offset (see {\tt{Cil.lval}}[\ref{type:Cil.lval}]). The host object (represented as
{\tt{Cil.lhost}}[\ref{type:Cil.lhost}]) can be a local or global variable or can be the object
pointed-to by a pointer expression. The offset (represented as
{\tt{Cil.offset}}[\ref{type:Cil.offset}]) is a sequence of field or array index designators.


 Both the typing rules and the meaning of an lvalue is very precisely
specified in CIL. 


 The following are a few useful function for operating on lvalues:\begin{itemize}
\item {\tt{Cil.mkMem}}[\ref{val:Cil.mkMem}] - makes an lvalue of {\tt{Mem}} kind. Use this to ensure
that certain equivalent forms of lvalues are canonized. 
For example, {\tt{*\&x = x}}. 
\item {\tt{Cil.typeOfLval}}[\ref{val:Cil.typeOfLval}] - the type of an lvalue
\item {\tt{Cil.typeOffset}}[\ref{val:Cil.typeOffset}] - the type of an offset, given the type of the
host. 
\item {\tt{Cil.addOffset}}[\ref{val:Cil.addOffset}] and {\tt{Cil.addOffsetLval}}[\ref{val:Cil.addOffsetLval}] - extend sequences
of offsets.
\item {\tt{Cil.removeOffset}}[\ref{val:Cil.removeOffset}] and {\tt{Cil.removeOffsetLval}}[\ref{val:Cil.removeOffsetLval}] - shrink sequences
of offsets.
\end{itemize}

The following equivalences hold \begin{verbatim}
Mem(AddrOf(Mem a, aoff)), off   = Mem a, aoff + off 
Mem(AddrOf(Var v, aoff)), off   = Var v, aoff + off 
AddrOf (Mem a, NoOffset)        = a                 
\end{verbatim}



\label{type:Cil.lval}\begin{ocamldoccode}
type lval = lhost * offset 
\end{ocamldoccode}
\index{lval@\verb`lval`}
\begin{ocamldocdescription}
An lvalue


\end{ocamldocdescription}




\label{type:Cil.lhost}\begin{ocamldoccode}
type lhost =
  | Var of varinfo
\end{ocamldoccode}
\begin{ocamldoccomment}
The host is a variable.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Mem of exp
\end{ocamldoccode}
\begin{ocamldoccomment}
The host is an object of type {\tt{T}} when the expression has pointer 
 {\tt{TPtr(T)}}.
\end{ocamldoccomment}
\index{lhost@\verb`lhost`}
\begin{ocamldocdescription}
The host part of an {\tt{Cil.lval}}[\ref{type:Cil.lval}].


\end{ocamldocdescription}




\label{type:Cil.offset}\begin{ocamldoccode}
type offset =
  | NoOffset
\end{ocamldoccode}
\begin{ocamldoccomment}
No offset. Can be applied to any lvalue and does 
 not change either the starting address or the type. 
 This is used when the lval consists of just a host 
 or as a terminator in a list of other kinds of 
 offsets.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Field of fieldinfo * offset
\end{ocamldoccode}
\begin{ocamldoccomment}
A field offset. Can be applied only to an lvalue 
 that denotes a structure or a union that contains 
 the mentioned field. This advances the offset to the 
 beginning of the mentioned field and changes the 
 type to the type of the mentioned field.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Index of exp * offset
\end{ocamldoccode}
\begin{ocamldoccomment}
An array index offset. Can be applied only to an 
 lvalue that denotes an array. This advances the 
 starting address of the lval to the beginning of the 
 mentioned array element and changes the denoted type 
 to be the type of the array element
\end{ocamldoccomment}
\index{offset@\verb`offset`}
\begin{ocamldocdescription}
The offset part of an {\tt{Cil.lval}}[\ref{type:Cil.lval}]. Each offset can be applied to certain 
 kinds of lvalues and its effect is that it advances the starting address 
 of the lvalue and changes the denoted type, essentially focusing to some 
 smaller lvalue that is contained in the original one.


\end{ocamldocdescription}




{\bf Initializers.} A special kind of expressions are those that can appear 
 as initializers for global variables (initialization of local variables is 
 turned into assignments). The initializers are represented as type 
 {\tt{Cil.init}}[\ref{type:Cil.init}]. You can create initializers with {\tt{Cil.makeZeroInit}}[\ref{val:Cil.makeZeroInit}] and you 
 can conveniently scan compound initializers them with 
 {\tt{Cil.foldLeftCompound}}[\ref{val:Cil.foldLeftCompound}].



\label{type:Cil.init}\begin{ocamldoccode}
type init =
  | SingleInit of exp
\end{ocamldoccode}
\begin{ocamldoccomment}
A single initializer
\end{ocamldoccomment}
\begin{ocamldoccode}
  | CompoundInit of typ * (offset * init) list
\end{ocamldoccode}
\begin{ocamldoccomment}
Used only for initializers of structures, unions and arrays. The 
 offsets are all of the form {\tt{Field(f, NoOffset)}} or {\tt{Index(i, \
 NoOffset)}} and specify the field or the index being initialized. For 
 structures all fields must have an initializer (except the unnamed 
 bitfields), in the proper order. This is necessary since the offsets 
 are not printed. For unions there must be exactly one initializer. If 
 the initializer is not for the first field then a field designator is 
 printed, so you better be on GCC since MSVC does not understand this. 
 For arrays, however, we allow you to give only a prefix of the 
 initializers. You can scan an initializer list with 
 {\tt{Cil.foldLeftCompound}}[\ref{val:Cil.foldLeftCompound}].
\end{ocamldoccomment}
\index{init@\verb`init`}
\begin{ocamldocdescription}
Initializers for global variables.


\end{ocamldocdescription}




\label{type:Cil.initinfo}\begin{ocamldoccode}
type initinfo = \{
  mutable init : init option ;
\}
\end{ocamldoccode}
\index{initinfo@\verb`initinfo`}
\begin{ocamldocdescription}
We want to be able to update an initializer in a global variable, so we 
 define it as a mutable field


\end{ocamldocdescription}




{\bf Function definitions.} 
A function definition is always introduced with a {\tt{GFun}} constructor at the
top level. All the information about the function is stored into a
{\tt{Cil.fundec}}[\ref{type:Cil.fundec}]. Some of the information (e.g. its name, type,
storage, attributes) is stored as a {\tt{Cil.varinfo}}[\ref{type:Cil.varinfo}] that is a field of the
{\tt{fundec}}. To refer to the function from the expression language you must use
the {\tt{varinfo}}. 


 The function definition contains, in addition to the body, a list of all the
local variables and separately a list of the formals. Both kind of variables
can be referred to in the body of the function. The formals must also be shared
with the formals that appear in the function type. For that reason, to
manipulate formals you should use the provided functions
{\tt{Cil.makeFormalVar}}[\ref{val:Cil.makeFormalVar}] and {\tt{Cil.setFormals}}[\ref{val:Cil.setFormals}] and {\tt{Cil.makeFormalVar}}[\ref{val:Cil.makeFormalVar}].



\label{type:Cil.fundec}\begin{ocamldoccode}
type fundec = \{
  mutable svar : varinfo ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Holds the name and type as a variable, so we can refer to it 
 easily from the program. All references to this function either 
 in a function call or in a prototype must point to the same 
 {\tt{varinfo}}.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable sformals : varinfo list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Formals. These must be in the same order and with the same 
 information as the formal information in the type of the function. 
 Use {\tt{Cil.setFormals}}[\ref{val:Cil.setFormals}] or 
 {\tt{Cil.setFunctionType}}[\ref{val:Cil.setFunctionType}] or {\tt{Cil.makeFormalVar}}[\ref{val:Cil.makeFormalVar}] 
 to set these formals and ensure that they 
 are reflected in the function type. Do not make copies of these 
 because the body refers to them.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable slocals : varinfo list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Locals. Does NOT include the sformals. Do not make copies of 
 these because the body refers to them.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable smaxid : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Max local id. Starts at 0. Used for 
 creating the names of new temporary 
 variables. Updated by 
 {\tt{Cil.makeLocalVar}}[\ref{val:Cil.makeLocalVar}] and 
 {\tt{Cil.makeTempVar}}[\ref{val:Cil.makeTempVar}]. You can also use 
 {\tt{Cil.setMaxId}}[\ref{val:Cil.setMaxId}] to set it after you 
 have added the formals and locals.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable sbody : block ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The function body.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable smaxstmtid : int option ;
\end{ocamldoccode}
\begin{ocamldoccomment}
max id of a (reachable) statement 
 in this function, if we have 
 computed it. range $=$ 0 $\ldots$ 
 (smaxstmtid-1). This is computed by 
 {\tt{Cil.computeCFGInfo}}[\ref{val:Cil.computeCFGInfo}].
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable sallstmts : stmt list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
After you call {\tt{Cil.computeCFGInfo}}[\ref{val:Cil.computeCFGInfo}] 
 this field is set to contain all 
 statements in the function
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{fundec@\verb`fundec`}
\begin{ocamldocdescription}
Function definitions.


\end{ocamldocdescription}




\label{type:Cil.block}\begin{ocamldoccode}
type block = \{
  mutable battrs : attributes ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Attributes for the block
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable bstmts : stmt list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The statements comprising the block
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{block@\verb`block`}
\begin{ocamldocdescription}
A block is a sequence of statements with the control falling through from 
    one element to the next


\end{ocamldocdescription}




{\bf Statements}. 
CIL statements are the structural elements that make the CFG. They are 
represented using the type {\tt{Cil.stmt}}[\ref{type:Cil.stmt}]. Every
statement has a (possibly empty) list of labels. The
{\tt{Cil.stmtkind}}[\ref{type:Cil.stmtkind}] field of a statement indicates what kind of statement it 
is.


 Use {\tt{Cil.mkStmt}}[\ref{val:Cil.mkStmt}] to make a statement and the fill-in the fields. 


CIL also comes with support for control-flow graphs. The {\tt{sid}} field in
{\tt{stmt}} can be used to give unique numbers to statements, and the {\tt{succs}}
and {\tt{preds}} fields can be used to maintain a list of successors and
predecessors for every statement. The CFG information is not computed by
default. Instead you must explicitly use the functions
{\tt{Cil.prepareCFG}}[\ref{val:Cil.prepareCFG}] and {\tt{Cil.computeCFGInfo}}[\ref{val:Cil.computeCFGInfo}] to do it.



\label{type:Cil.stmt}\begin{ocamldoccode}
type stmt = \{
  mutable labels : label list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Whether the statement starts with some labels, case statements or 
 default statements.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable skind : stmtkind ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The kind of statement
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable sid : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
A number ($\geq$ 0) that is unique in a function. Filled in only after 
 the CFG is computed.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable succs : stmt list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The successor statements. They can always be computed from the skind 
 and the context in which this statement appears. Filled in only after 
 the CFG is computed.
\end{ocamldoccomment}
\begin{ocamldoccode}
  mutable preds : stmt list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The inverse of the succs function.
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{stmt@\verb`stmt`}
\begin{ocamldocdescription}
Statements.


\end{ocamldocdescription}




\label{type:Cil.label}\begin{ocamldoccode}
type label =
  | Label of string * location * bool
\end{ocamldoccode}
\begin{ocamldoccomment}
A real label. If the bool is "true", the label is from the 
 input source program. If the bool is "false", the label was 
 created by CIL or some other transformation
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Case of exp * location
\end{ocamldoccode}
\begin{ocamldoccomment}
A case statement. This expression 
 is lowered into a constant if 
 {\tt{Cil.lowerConstants}}[\ref{val:Cil.lowerConstants}] is set to 
 true.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Default of location
\end{ocamldoccode}
\begin{ocamldoccomment}
A default statement
\end{ocamldoccomment}
\index{label@\verb`label`}
\begin{ocamldocdescription}
Labels


\end{ocamldocdescription}




\label{type:Cil.stmtkind}\begin{ocamldoccode}
type stmtkind =
  | Instr of instr list
\end{ocamldoccode}
\begin{ocamldoccomment}
A group of instructions that do not contain control flow. Control 
 implicitly falls through.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Return of exp option * location
\end{ocamldoccode}
\begin{ocamldoccomment}
The return statement. This is a leaf in the CFG.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Goto of stmt ref * location
\end{ocamldoccode}
\begin{ocamldoccomment}
A goto statement. Appears from actual goto's in the code or from 
 goto's that have been inserted during elaboration. The reference 
 points to the statement that is the target of the Goto. This means that 
 you have to update the reference whenever you replace the target 
 statement. The target statement MUST have at least a label.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Break of location
\end{ocamldoccode}
\begin{ocamldoccomment}
A break to the end of the nearest enclosing Loop or Switch
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Continue of location
\end{ocamldoccode}
\begin{ocamldoccomment}
A continue to the start of the nearest enclosing {\tt{Loop}}
\end{ocamldoccomment}
\begin{ocamldoccode}
  | If of exp * block * block * location
\end{ocamldoccode}
\begin{ocamldoccomment}
A conditional. Two successors, the "then" and the "else" branches. 
 Both branches fall-through to the successor of the If statement.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Switch of exp * block * stmt list * location
\end{ocamldoccode}
\begin{ocamldoccomment}
A switch statement. The statements that implement the cases can be 
 reached through the provided list. For each such target you can find 
 among its labels what cases it implements. The statements that 
 implement the cases are somewhere within the provided {\tt{block}}.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Loop of block * location * stmt option * stmt option
\end{ocamldoccode}
\begin{ocamldoccomment}
A {\tt{while(1)}} loop. The termination test is implemented in the body of 
 a loop using a {\tt{Break}} statement. If prepareCFG has been called,
 the first stmt option will point to the stmt containing the continue
 label for this loop and the second will point to the stmt containing
 the break label for this loop.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Block of block
\end{ocamldoccode}
\begin{ocamldoccomment}
Just a block of statements. Use it as a way to keep some block 
 attributes local
\end{ocamldoccomment}
\begin{ocamldoccode}
  | TryFinally of block * block * location
  | TryExcept of block * (instr list * exp) * block * location
\end{ocamldoccode}
\index{stmtkind@\verb`stmtkind`}
\begin{ocamldocdescription}
The various kinds of control-flow statements statements


\end{ocamldocdescription}




{\bf Instructions}. 
 An instruction {\tt{Cil.instr}}[\ref{type:Cil.instr}] is a statement that has no local
(intraprocedural) control flow. It can be either an assignment,
function call, or an inline assembly instruction.



\label{type:Cil.instr}\begin{ocamldoccode}
type instr =
  | Set of lval * exp * location
\end{ocamldoccode}
\begin{ocamldoccomment}
An assignment. The type of the expression is guaranteed to be the same 
 with that of the lvalue
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Call of lval option * exp * exp list * location
\end{ocamldoccode}
\begin{ocamldoccomment}
A function call with the (optional) result placed in an lval. It is 
 possible that the returned type of the function is not identical to 
 that of the lvalue. In that case a cast is printed. The type of the 
 actual arguments are identical to those of the declared formals. The 
 number of arguments is the same as that of the declared formals, except 
 for vararg functions. This construct is also used to encode a call to 
 "\_\_builtin\_va\_arg". In this case the second argument (which should be a 
 type T) is encoded SizeOf(T)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Asm of attributes * string list * (string option * string * lval) list
   * (string option * string * exp) list * string list * location
\end{ocamldoccode}
\begin{ocamldoccomment}
There are for storing inline assembly. They follow the GCC 
 specification: 
\begin{verbatim}
  asm [volatile] ("...template..." "..template.."
                  : "c1" (o1), "c2" (o2), ..., "cN" (oN)
                  : "d1" (i1), "d2" (i2), ..., "dM" (iM)
                  : "r1", "r2", ..., "nL" );
\end{verbatim}


where the parts are

\begin{itemize}
\item {\tt{volatile}} (optional): when present, the assembler instruction
    cannot be removed, moved, or otherwise optimized
\item template: a sequence of strings, with \%0, \%1, \%2, etc. in the string to 
    refer to the input and output expressions. I think they're numbered
    consecutively, but the docs don't specify. Each string is printed on 
    a separate line. This is the only part that is present for MSVC inline
    assembly.
\item "ci" (oi): pairs of constraint-string and output-lval; the 
    constraint specifies that the register used must have some
    property, like being a floating-point register; the constraint
    string for outputs also has "$=$" to indicate it is written, or
    "+" to indicate it is both read and written; 'oi' is the
    name of a C lvalue (probably a variable name) to be used as
    the output destination
\item "dj" (ij): pairs of constraint and input expression; the constraint
    is similar to the "ci"s.  the 'ij' is an arbitrary C expression
    to be loaded into the corresponding register
\item "rk": registers to be regarded as "clobbered" by the instruction;
    "memory" may be specified for arbitrary memory effects
\end{itemize}

an example (from gcc manual):
\begin{verbatim}
  asm volatile ("movc3 %0,%1,%2"
                : /* no outputs */
                : "g" (from), "g" (to), "g" (count)
                : "r0", "r1", "r2", "r3", "r4", "r5");
\end{verbatim}


 Starting with gcc 3.1, the operands may have names:


\begin{verbatim}
  asm volatile ("movc3 %[in0],%1,%2"
                : /* no outputs */
                : [in0] "g" (from), "g" (to), "g" (count)
                : "r0", "r1", "r2", "r3", "r4", "r5");
\end{verbatim}
\end{ocamldoccomment}
\index{instr@\verb`instr`}
\begin{ocamldocdescription}
Instructions.


\end{ocamldocdescription}




\label{type:Cil.location}\begin{ocamldoccode}
type location = \{
  line : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The line number. -1 means "do not know"
\end{ocamldoccomment}
\begin{ocamldoccode}
  file : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The name of the source file
\end{ocamldoccomment}
\begin{ocamldoccode}
  byte : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The byte position in the source file
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{location@\verb`location`}
\begin{ocamldocdescription}
Describes a location in a source file.


\end{ocamldocdescription}




\label{type:Cil.typsig}\begin{ocamldoccode}
type typsig =
  | TSArray of typsig * int64 option * attribute list
  | TSPtr of typsig * attribute list
  | TSComp of bool * string * attribute list
  | TSFun of typsig * typsig list * bool * attribute list
  | TSEnum of string * attribute list
  | TSBase of typ
\end{ocamldoccode}
\index{typsig@\verb`typsig`}
\begin{ocamldocdescription}
Type signatures. Two types are identical iff they have identical 
 signatures. These contain the same information as types but canonicalized. 
 For example, two function types that are identical except for the name of 
 the formal arguments are given the same signature. Also, {\tt{TNamed}} 
 constructors are unrolled.


\end{ocamldocdescription}




{\bf Lowering Options}



\label{val:Cil.lowerConstants}\begin{ocamldoccode}
val lowerConstants : bool ref
\end{ocamldoccode}
\index{lowerConstants@\verb`lowerConstants`}
\begin{ocamldocdescription}
Do lower constants (default true)


\end{ocamldocdescription}




\label{val:Cil.insertImplicitCasts}\begin{ocamldoccode}
val insertImplicitCasts : bool ref
\end{ocamldoccode}
\index{insertImplicitCasts@\verb`insertImplicitCasts`}
\begin{ocamldocdescription}
Do insert implicit casts (default true)


\end{ocamldocdescription}




\label{type:Cil.featureDescr}\begin{ocamldoccode}
type featureDescr = \{
  fd_enabled : bool ref ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The enable flag. Set to default value
\end{ocamldoccomment}
\begin{ocamldoccode}
  fd_name : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
This is used to construct an option "--doxxx" and "--dontxxx" that 
 enable and disable the feature
\end{ocamldoccomment}
\begin{ocamldoccode}
  fd_description : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
A longer name that can be used to document the new options
\end{ocamldoccomment}
\begin{ocamldoccode}
  fd_extraopt : (string * Arg.spec * string) list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Additional command line options.  The description strings should
        usually start with a space for Arg.align to print the --help nicely.
\end{ocamldoccomment}
\begin{ocamldoccode}
  fd_doit : file -> unit ;
\end{ocamldoccode}
\begin{ocamldoccomment}
This performs the transformation
\end{ocamldoccomment}
\begin{ocamldoccode}
  fd_post_check : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Whether to perform a CIL consistency checking after this stage, if 
 checking is enabled (--check is passed to cilly). Set this to true if 
 your feature makes any changes for the program.
\end{ocamldoccomment}
\begin{ocamldoccode}
\}
\end{ocamldoccode}
\index{featureDescr@\verb`featureDescr`}
\begin{ocamldocdescription}
To be able to add/remove features easily, each feature should be package 
 as an interface with the following interface. These features should be


\end{ocamldocdescription}




\label{val:Cil.compareLoc}\begin{ocamldoccode}
val compareLoc : location -> location -> int
\end{ocamldoccode}
\index{compareLoc@\verb`compareLoc`}
\begin{ocamldocdescription}
Comparison function for locations.
* Compares first by filename, then line, then byte


\end{ocamldocdescription}




{\bf Values for manipulating globals}



\label{val:Cil.emptyFunction}\begin{ocamldoccode}
val emptyFunction : string -> fundec
\end{ocamldoccode}
\index{emptyFunction@\verb`emptyFunction`}
\begin{ocamldocdescription}
Make an empty function


\end{ocamldocdescription}




\label{val:Cil.setFormals}\begin{ocamldoccode}
val setFormals : fundec -> varinfo list -> unit
\end{ocamldoccode}
\index{setFormals@\verb`setFormals`}
\begin{ocamldocdescription}
Update the formals of a {\tt{fundec}} and make sure that the function type 
    has the same information. Will copy the name as well into the type.


\end{ocamldocdescription}




\label{val:Cil.setFunctionType}\begin{ocamldoccode}
val setFunctionType : fundec -> typ -> unit
\end{ocamldoccode}
\index{setFunctionType@\verb`setFunctionType`}
\begin{ocamldocdescription}
Set the types of arguments and results as given by the function type 
 passed as the second argument. Will not copy the names from the function 
 type to the formals


\end{ocamldocdescription}




\label{val:Cil.setFunctionTypeMakeFormals}\begin{ocamldoccode}
val setFunctionTypeMakeFormals : fundec -> typ -> unit
\end{ocamldoccode}
\index{setFunctionTypeMakeFormals@\verb`setFunctionTypeMakeFormals`}
\begin{ocamldocdescription}
Set the type of the function and make formal arguments for them


\end{ocamldocdescription}




\label{val:Cil.setMaxId}\begin{ocamldoccode}
val setMaxId : fundec -> unit
\end{ocamldoccode}
\index{setMaxId@\verb`setMaxId`}
\begin{ocamldocdescription}
Update the smaxid after you have populated with locals and formals 
 (unless you constructed those using {\tt{Cil.makeLocalVar}}[\ref{val:Cil.makeLocalVar}] or 
 {\tt{Cil.makeTempVar}}[\ref{val:Cil.makeTempVar}].


\end{ocamldocdescription}




\label{val:Cil.dummyFunDec}\begin{ocamldoccode}
val dummyFunDec : fundec
\end{ocamldoccode}
\index{dummyFunDec@\verb`dummyFunDec`}
\begin{ocamldocdescription}
A dummy function declaration handy when you need one as a placeholder. It 
 contains inside a dummy varinfo.


\end{ocamldocdescription}




\label{val:Cil.dummyFile}\begin{ocamldoccode}
val dummyFile : file
\end{ocamldoccode}
\index{dummyFile@\verb`dummyFile`}
\begin{ocamldocdescription}
A dummy file


\end{ocamldocdescription}




\label{val:Cil.saveBinaryFile}\begin{ocamldoccode}
val saveBinaryFile : file -> string -> unit
\end{ocamldoccode}
\index{saveBinaryFile@\verb`saveBinaryFile`}
\begin{ocamldocdescription}
Write a {\tt{Cil.file}}[\ref{type:Cil.file}] in binary form to the filesystem. The file can be
 read back in later using {\tt{Cil.loadBinaryFile}}[\ref{val:Cil.loadBinaryFile}], possibly saving parsing
 time. The second argument is the name of the file that should be
 created.


\end{ocamldocdescription}




\label{val:Cil.saveBinaryFileChannel}\begin{ocamldoccode}
val saveBinaryFileChannel : file -> out_channel -> unit
\end{ocamldoccode}
\index{saveBinaryFileChannel@\verb`saveBinaryFileChannel`}
\begin{ocamldocdescription}
Write a {\tt{Cil.file}}[\ref{type:Cil.file}] in binary form to the filesystem. The file can be
 read back in later using {\tt{Cil.loadBinaryFile}}[\ref{val:Cil.loadBinaryFile}], possibly saving parsing
 time. Does not close the channel.


\end{ocamldocdescription}




\label{val:Cil.loadBinaryFile}\begin{ocamldoccode}
val loadBinaryFile : string -> file
\end{ocamldoccode}
\index{loadBinaryFile@\verb`loadBinaryFile`}
\begin{ocamldocdescription}
Read a {\tt{Cil.file}}[\ref{type:Cil.file}] in binary form from the filesystem. The first
 argument is the name of a file previously created by
 {\tt{Cil.saveBinaryFile}}[\ref{val:Cil.saveBinaryFile}]. Because this also reads some global state,
 this should be called before any other CIL code is parsed or generated.


\end{ocamldocdescription}




\label{val:Cil.getGlobInit}\begin{ocamldoccode}
val getGlobInit : ?main_name:string -> file -> fundec
\end{ocamldoccode}
\index{getGlobInit@\verb`getGlobInit`}
\begin{ocamldocdescription}
Get the global initializer and create one if it does not already exist. 
 When it creates a global initializer it attempts to place a call to it in 
 the main function named by the optional argument (default "main")


\end{ocamldocdescription}




\label{val:Cil.iterGlobals}\begin{ocamldoccode}
val iterGlobals : file -> (global -> unit) -> unit
\end{ocamldoccode}
\index{iterGlobals@\verb`iterGlobals`}
\begin{ocamldocdescription}
Iterate over all globals, including the global initializer


\end{ocamldocdescription}




\label{val:Cil.foldGlobals}\begin{ocamldoccode}
val foldGlobals : file -> ('a -> global -> 'a) -> 'a -> 'a
\end{ocamldoccode}
\index{foldGlobals@\verb`foldGlobals`}
\begin{ocamldocdescription}
Fold over all globals, including the global initializer


\end{ocamldocdescription}




\label{val:Cil.mapGlobals}\begin{ocamldoccode}
val mapGlobals : file -> (global -> global) -> unit
\end{ocamldoccode}
\index{mapGlobals@\verb`mapGlobals`}
\begin{ocamldocdescription}
Map over all globals, including the global initializer and change things 
    in place


\end{ocamldocdescription}




\label{val:Cil.findOrCreateFunc}\begin{ocamldoccode}
val findOrCreateFunc : file -> string -> typ -> varinfo
\end{ocamldoccode}
\index{findOrCreateFunc@\verb`findOrCreateFunc`}
\begin{ocamldocdescription}
Find a function or function prototype with the given name in the file.
 If it does not exist, create a prototype with the given type, and return
 the new varinfo.  This is useful when you need to call a libc function
 whose prototype may or may not already exist in the file.


 Because the new prototype is added to the start of the file, you shouldn't
 refer to any struct or union types in the function type.


\end{ocamldocdescription}




\label{val:Cil.new-underscoresid}\begin{ocamldoccode}
val new_sid : unit -> int
\end{ocamldoccode}
\index{new-underscoresid@\verb`new_sid`}




\label{val:Cil.prepareCFG}\begin{ocamldoccode}
val prepareCFG : fundec -> unit
\end{ocamldoccode}
\index{prepareCFG@\verb`prepareCFG`}
\begin{ocamldocdescription}
Prepare a function for CFG information computation by
 {\tt{Cil.computeCFGInfo}}[\ref{val:Cil.computeCFGInfo}]. This function converts all {\tt{Break}}, {\tt{Switch}},
 {\tt{Default}} and {\tt{Continue}} {\tt{Cil.stmtkind}}[\ref{type:Cil.stmtkind}]s and {\tt{Cil.label}}[\ref{type:Cil.label}]s into {\tt{If}}s
 and {\tt{Goto}}s, giving the function body a very CFG-like character. This
 function modifies its argument in place.


\end{ocamldocdescription}




\label{val:Cil.computeCFGInfo}\begin{ocamldoccode}
val computeCFGInfo : fundec -> bool -> unit
\end{ocamldoccode}
\index{computeCFGInfo@\verb`computeCFGInfo`}
\begin{ocamldocdescription}
Compute the CFG information for all statements in a fundec and return a 
 list of the statements. The input fundec cannot have {\tt{Break}}, {\tt{Switch}}, 
 {\tt{Default}}, or {\tt{Continue}} {\tt{Cil.stmtkind}}[\ref{type:Cil.stmtkind}]s or {\tt{Cil.label}}[\ref{type:Cil.label}]s. Use
 {\tt{Cil.prepareCFG}}[\ref{val:Cil.prepareCFG}] to transform them away.  The second argument should
 be {\tt{true}} if you wish a global statement number, {\tt{false}} if you wish a
 local (per-function) statement numbering. The list of statements is set 
 in the sallstmts field of a fundec. 


 NOTE: unless you want the simpler control-flow graph provided by
 prepareCFG, or you need the function's smaxstmtid and sallstmt fields
 filled in, we recommend you use {\tt{Cfg.computeFileCFG}}[\ref{val:Cfg.computeFileCFG}] instead of this
 function to compute control-flow information.
 {\tt{Cfg.computeFileCFG}}[\ref{val:Cfg.computeFileCFG}] is newer and will handle switch, break, and
 continue correctly.


\end{ocamldocdescription}




\label{val:Cil.copyFunction}\begin{ocamldoccode}
val copyFunction : fundec -> string -> fundec
\end{ocamldoccode}
\index{copyFunction@\verb`copyFunction`}
\begin{ocamldocdescription}
Create a deep copy of a function. There should be no sharing between the 
 copy and the original function


\end{ocamldocdescription}




\label{val:Cil.pushGlobal}\begin{ocamldoccode}
val pushGlobal :
  global ->
  types:global list ref ->
  variables:global list ref -> unit
\end{ocamldoccode}
\index{pushGlobal@\verb`pushGlobal`}
\begin{ocamldocdescription}
CIL keeps the types at the beginning of the file and the variables at the 
 end of the file. This function will take a global and add it to the 
 corresponding stack. Its operation is actually more complicated because if 
 the global declares a type that contains references to variables (e.g. in 
 sizeof in an array length) then it will also add declarations for the 
 variables to the types stack


\end{ocamldocdescription}




\label{val:Cil.invalidStmt}\begin{ocamldoccode}
val invalidStmt : stmt
\end{ocamldoccode}
\index{invalidStmt@\verb`invalidStmt`}
\begin{ocamldocdescription}
An empty statement. Used in pretty printing


\end{ocamldocdescription}




\label{val:Cil.builtinFunctions}\begin{ocamldoccode}
val builtinFunctions : (string, typ * typ list * bool) Hashtbl.t
\end{ocamldoccode}
\index{builtinFunctions@\verb`builtinFunctions`}
\begin{ocamldocdescription}
A list of the built-in functions for the current compiler (GCC or
 MSVC, depending on {\tt{!msvcMode}}).  Maps the name to the
 result and argument types, and whether it is vararg.
 Initialized by {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}]


 This map replaces {\tt{gccBuiltins}} and {\tt{msvcBuiltins}} in previous
 versions of CIL.


\end{ocamldocdescription}




\label{val:Cil.builtinLoc}\begin{ocamldoccode}
val builtinLoc : location
\end{ocamldoccode}
\index{builtinLoc@\verb`builtinLoc`}
\begin{ocamldocdescription}
This is used as the location of the prototypes of builtin functions.


\end{ocamldocdescription}




{\bf Values for manipulating initializers}



\label{val:Cil.makeZeroInit}\begin{ocamldoccode}
val makeZeroInit : typ -> init
\end{ocamldoccode}
\index{makeZeroInit@\verb`makeZeroInit`}
\begin{ocamldocdescription}
Make a initializer for zero-ing a data type


\end{ocamldocdescription}




\label{val:Cil.foldLeftCompound}\begin{ocamldoccode}
val foldLeftCompound :
  implicit:bool ->
  doinit:(offset -> init -> typ -> 'a -> 'a) ->
  ct:typ -> initl:(offset * init) list -> acc:'a -> 'a
\end{ocamldoccode}
\index{foldLeftCompound@\verb`foldLeftCompound`}
\begin{ocamldocdescription}
Fold over the list of initializers in a Compound (not also the nested 
 ones). {\tt{doinit}} is called on every present initializer, even if it is of 
 compound type. The parameters of {\tt{doinit}} are: the offset in the compound 
 (this is {\tt{Field(f,NoOffset)}} or {\tt{Index(i,NoOffset)}}), the initializer 
 value, expected type of the initializer value, accumulator. In the case of 
 arrays there might be missing zero-initializers at the end of the list. 
 These are scanned only if {\tt{implicit}} is true. This is much like 
 {\tt{List.fold\_left}} except we also pass the type of the initializer. 


 This is a good way to use it to scan even nested initializers :
\begin{verbatim}
  let rec myInit (lv: lval) (i: init) (acc: 'a) : 'a = 
      match i with 
        SingleInit e -> ... do something with lv and e and acc ...
      | CompoundInit (ct, initl) ->  
         foldLeftCompound ~implicit:false
             ~doinit:(fun off' i' t' acc -> 
                        myInit (addOffsetLval lv off') i' acc)
             ~ct:ct
             ~initl:initl
             ~acc:acc\end{verbatim}


\end{ocamldocdescription}




{\bf Values for manipulating types}



\label{val:Cil.voidType}\begin{ocamldoccode}
val voidType : typ
\end{ocamldoccode}
\index{voidType@\verb`voidType`}
\begin{ocamldocdescription}
void


\end{ocamldocdescription}




\label{val:Cil.isVoidType}\begin{ocamldoccode}
val isVoidType : typ -> bool
\end{ocamldoccode}
\index{isVoidType@\verb`isVoidType`}
\begin{ocamldocdescription}
is the given type "void"?


\end{ocamldocdescription}




\label{val:Cil.isVoidPtrType}\begin{ocamldoccode}
val isVoidPtrType : typ -> bool
\end{ocamldoccode}
\index{isVoidPtrType@\verb`isVoidPtrType`}
\begin{ocamldocdescription}
is the given type "void *"?


\end{ocamldocdescription}




\label{val:Cil.intType}\begin{ocamldoccode}
val intType : typ
\end{ocamldoccode}
\index{intType@\verb`intType`}
\begin{ocamldocdescription}
int


\end{ocamldocdescription}




\label{val:Cil.uintType}\begin{ocamldoccode}
val uintType : typ
\end{ocamldoccode}
\index{uintType@\verb`uintType`}
\begin{ocamldocdescription}
unsigned int


\end{ocamldocdescription}




\label{val:Cil.longType}\begin{ocamldoccode}
val longType : typ
\end{ocamldoccode}
\index{longType@\verb`longType`}
\begin{ocamldocdescription}
long


\end{ocamldocdescription}




\label{val:Cil.ulongType}\begin{ocamldoccode}
val ulongType : typ
\end{ocamldoccode}
\index{ulongType@\verb`ulongType`}
\begin{ocamldocdescription}
unsigned long


\end{ocamldocdescription}




\label{val:Cil.charType}\begin{ocamldoccode}
val charType : typ
\end{ocamldoccode}
\index{charType@\verb`charType`}
\begin{ocamldocdescription}
char


\end{ocamldocdescription}




\label{val:Cil.charPtrType}\begin{ocamldoccode}
val charPtrType : typ
\end{ocamldoccode}
\index{charPtrType@\verb`charPtrType`}
\begin{ocamldocdescription}
char *


\end{ocamldocdescription}




\label{val:Cil.wcharKind}\begin{ocamldoccode}
val wcharKind : ikind ref
\end{ocamldoccode}
\index{wcharKind@\verb`wcharKind`}
\begin{ocamldocdescription}
wchar\_t (depends on architecture) and is set when you call 
 {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}].


\end{ocamldocdescription}




\label{val:Cil.wcharType}\begin{ocamldoccode}
val wcharType : typ ref
\end{ocamldoccode}
\index{wcharType@\verb`wcharType`}




\label{val:Cil.charConstPtrType}\begin{ocamldoccode}
val charConstPtrType : typ
\end{ocamldoccode}
\index{charConstPtrType@\verb`charConstPtrType`}
\begin{ocamldocdescription}
char const *


\end{ocamldocdescription}




\label{val:Cil.voidPtrType}\begin{ocamldoccode}
val voidPtrType : typ
\end{ocamldoccode}
\index{voidPtrType@\verb`voidPtrType`}
\begin{ocamldocdescription}
void *


\end{ocamldocdescription}




\label{val:Cil.intPtrType}\begin{ocamldoccode}
val intPtrType : typ
\end{ocamldoccode}
\index{intPtrType@\verb`intPtrType`}
\begin{ocamldocdescription}
int *


\end{ocamldocdescription}




\label{val:Cil.uintPtrType}\begin{ocamldoccode}
val uintPtrType : typ
\end{ocamldoccode}
\index{uintPtrType@\verb`uintPtrType`}
\begin{ocamldocdescription}
unsigned int *


\end{ocamldocdescription}




\label{val:Cil.doubleType}\begin{ocamldoccode}
val doubleType : typ
\end{ocamldoccode}
\index{doubleType@\verb`doubleType`}
\begin{ocamldocdescription}
double


\end{ocamldocdescription}




\label{val:Cil.upointType}\begin{ocamldoccode}
val upointType : typ ref
\end{ocamldoccode}
\index{upointType@\verb`upointType`}
\begin{ocamldocdescription}
An unsigned integer type that fits pointers. Depends on {\tt{Cil.msvcMode}}[\ref{val:Cil.msvcMode}] 
  and is set when you call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}].


\end{ocamldocdescription}




\label{val:Cil.typeOfSizeOf}\begin{ocamldoccode}
val typeOfSizeOf : typ ref
\end{ocamldoccode}
\index{typeOfSizeOf@\verb`typeOfSizeOf`}
\begin{ocamldocdescription}
An unsigned integer type that is the type of sizeof. Depends on 
 {\tt{Cil.msvcMode}}[\ref{val:Cil.msvcMode}] and is set when you call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}].


\end{ocamldocdescription}




\label{val:Cil.kindOfSizeOf}\begin{ocamldoccode}
val kindOfSizeOf : ikind ref
\end{ocamldoccode}
\index{kindOfSizeOf@\verb`kindOfSizeOf`}
\begin{ocamldocdescription}
The integer kind of {\tt{Cil.typeOfSizeOf}}[\ref{val:Cil.typeOfSizeOf}]. 
  Set when you call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}].


\end{ocamldocdescription}




\label{val:Cil.isSigned}\begin{ocamldoccode}
val isSigned : ikind -> bool
\end{ocamldoccode}
\index{isSigned@\verb`isSigned`}
\begin{ocamldocdescription}
Returns true if and only if the given integer type is signed.


\end{ocamldocdescription}




\label{val:Cil.mkCompInfo}\begin{ocamldoccode}
val mkCompInfo :
  bool ->
  string ->
  (compinfo ->
   (string * typ * int option * attributes * location) list) ->
  attributes -> compinfo
\end{ocamldoccode}
\index{mkCompInfo@\verb`mkCompInfo`}
\begin{ocamldocdescription}
Creates a a (potentially recursive) composite type. The arguments are: 
 (1) a boolean indicating whether it is a struct or a union, (2) the name 
 (always non-empty), (3) a function that when given a representation of the 
 structure type constructs the type of the fields recursive type (the first 
 argument is only useful when some fields need to refer to the type of the 
 structure itself), and (4) a list of attributes to be associated with the 
 composite type. The resulting compinfo has the field "cdefined" only if 
 the list of fields is non-empty.


\end{ocamldocdescription}




\label{val:Cil.copyCompInfo}\begin{ocamldoccode}
val copyCompInfo : compinfo -> string -> compinfo
\end{ocamldoccode}
\index{copyCompInfo@\verb`copyCompInfo`}
\begin{ocamldocdescription}
Makes a shallow copy of a {\tt{Cil.compinfo}}[\ref{type:Cil.compinfo}] changing the name and the key.


\end{ocamldocdescription}




\label{val:Cil.missingFieldName}\begin{ocamldoccode}
val missingFieldName : string
\end{ocamldoccode}
\index{missingFieldName@\verb`missingFieldName`}
\begin{ocamldocdescription}
This is a constant used as the name of an unnamed bitfield. These fields
    do not participate in initialization and their name is not printed.


\end{ocamldocdescription}




\label{val:Cil.compFullName}\begin{ocamldoccode}
val compFullName : compinfo -> string
\end{ocamldoccode}
\index{compFullName@\verb`compFullName`}
\begin{ocamldocdescription}
Get the full name of a comp


\end{ocamldocdescription}




\label{val:Cil.isCompleteType}\begin{ocamldoccode}
val isCompleteType : typ -> bool
\end{ocamldoccode}
\index{isCompleteType@\verb`isCompleteType`}
\begin{ocamldocdescription}
Returns true if this is a complete type. 
   This means that sizeof(t) makes sense. 
   Incomplete types are not yet defined 
   structures and empty arrays.


\end{ocamldocdescription}




\label{val:Cil.unrollType}\begin{ocamldoccode}
val unrollType : typ -> typ
\end{ocamldoccode}
\index{unrollType@\verb`unrollType`}
\begin{ocamldocdescription}
Unroll a type until it exposes a non 
 {\tt{TNamed}}. Will collect all attributes appearing in {\tt{TNamed}}!!!


\end{ocamldocdescription}




\label{val:Cil.unrollTypeDeep}\begin{ocamldoccode}
val unrollTypeDeep : typ -> typ
\end{ocamldoccode}
\index{unrollTypeDeep@\verb`unrollTypeDeep`}
\begin{ocamldocdescription}
Unroll all the TNamed in a type (even under type constructors such as 
 {\tt{TPtr}}, {\tt{TFun}} or {\tt{TArray}}. Does not unroll the types of fields in {\tt{TComp}} 
 types. Will collect all attributes


\end{ocamldocdescription}




\label{val:Cil.separateStorageModifiers}\begin{ocamldoccode}
val separateStorageModifiers :
  attribute list -> attribute list * attribute list
\end{ocamldoccode}
\index{separateStorageModifiers@\verb`separateStorageModifiers`}
\begin{ocamldocdescription}
Separate out the storage-modifier name attributes


\end{ocamldocdescription}




\label{val:Cil.isIntegralType}\begin{ocamldoccode}
val isIntegralType : typ -> bool
\end{ocamldoccode}
\index{isIntegralType@\verb`isIntegralType`}
\begin{ocamldocdescription}
True if the argument is an integral type (i.e. integer or enum)


\end{ocamldocdescription}




\label{val:Cil.isArithmeticType}\begin{ocamldoccode}
val isArithmeticType : typ -> bool
\end{ocamldoccode}
\index{isArithmeticType@\verb`isArithmeticType`}
\begin{ocamldocdescription}
True if the argument is an arithmetic type (i.e. integer, enum or 
    floating point


\end{ocamldocdescription}




\label{val:Cil.isPointerType}\begin{ocamldoccode}
val isPointerType : typ -> bool
\end{ocamldoccode}
\index{isPointerType@\verb`isPointerType`}
\begin{ocamldocdescription}
True if the argument is a pointer type


\end{ocamldocdescription}




\label{val:Cil.isScalarType}\begin{ocamldoccode}
val isScalarType : typ -> bool
\end{ocamldoccode}
\index{isScalarType@\verb`isScalarType`}
\begin{ocamldocdescription}
True if the argument is a scalar type


\end{ocamldocdescription}




\label{val:Cil.isFunctionType}\begin{ocamldoccode}
val isFunctionType : typ -> bool
\end{ocamldoccode}
\index{isFunctionType@\verb`isFunctionType`}
\begin{ocamldocdescription}
True if the argument is a function type


\end{ocamldocdescription}




\label{val:Cil.argsToList}\begin{ocamldoccode}
val argsToList :
  (string * typ * attributes) list option ->
  (string * typ * attributes) list
\end{ocamldoccode}
\index{argsToList@\verb`argsToList`}
\begin{ocamldocdescription}
Obtain the argument list ([] if None)


\end{ocamldocdescription}




\label{val:Cil.isArrayType}\begin{ocamldoccode}
val isArrayType : typ -> bool
\end{ocamldoccode}
\index{isArrayType@\verb`isArrayType`}
\begin{ocamldocdescription}
True if the argument is an array type


\end{ocamldocdescription}




\label{exception:Cil.LenOfArray}\begin{ocamldoccode}
exception LenOfArray
\end{ocamldoccode}
\index{LenOfArray@\verb`LenOfArray`}
\begin{ocamldocdescription}
Raised when {\tt{Cil.lenOfArray}}[\ref{val:Cil.lenOfArray}] fails either because the length is {\tt{None}} 
 or because it is a non-constant expression


\end{ocamldocdescription}




\label{val:Cil.lenOfArray}\begin{ocamldoccode}
val lenOfArray : exp option -> int
\end{ocamldoccode}
\index{lenOfArray@\verb`lenOfArray`}
\begin{ocamldocdescription}
Call to compute the array length as present in the array type, to an 
 integer. Raises {\tt{Cil.LenOfArray}}[\ref{exception:Cil.LenOfArray}] if not able to compute the length, such 
 as when there is no length or the length is not a constant.


\end{ocamldocdescription}




\label{val:Cil.getCompField}\begin{ocamldoccode}
val getCompField : compinfo -> string -> fieldinfo
\end{ocamldoccode}
\index{getCompField@\verb`getCompField`}
\begin{ocamldocdescription}
Return a named fieldinfo in compinfo, or raise Not\_found


\end{ocamldocdescription}




\label{type:Cil.existsAction}\begin{ocamldoccode}
type existsAction =
  | ExistsTrue
\end{ocamldoccode}
\begin{ocamldoccomment}
We have found it
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ExistsFalse
\end{ocamldoccode}
\begin{ocamldoccomment}
Stop processing this branch
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ExistsMaybe
\end{ocamldoccode}
\begin{ocamldoccomment}
This node is not what we are 
 looking for but maybe its 
 successors are
\end{ocamldoccomment}
\index{existsAction@\verb`existsAction`}
\begin{ocamldocdescription}
A datatype to be used in conjunction with {\tt{existsType}}


\end{ocamldocdescription}




\label{val:Cil.existsType}\begin{ocamldoccode}
val existsType : (typ -> existsAction) -> typ -> bool
\end{ocamldoccode}
\index{existsType@\verb`existsType`}
\begin{ocamldocdescription}
Scans a type by applying the function on all elements. 
    When the function returns ExistsTrue, the scan stops with
    true. When the function returns ExistsFalse then the current branch is not
    scanned anymore. Care is taken to 
    apply the function only once on each composite type, thus avoiding 
    circularity. When the function returns ExistsMaybe then the types that 
    construct the current type are scanned (e.g. the base type for TPtr and 
    TArray, the type of fields for a TComp, etc).


\end{ocamldocdescription}




\label{val:Cil.splitFunctionType}\begin{ocamldoccode}
val splitFunctionType :
  typ ->
  typ * (string * typ * attributes) list option * bool *
  attributes
\end{ocamldoccode}
\index{splitFunctionType@\verb`splitFunctionType`}
\begin{ocamldocdescription}
Given a function type split it into return type, 
 arguments, is\_vararg and attributes. An error is raised if the type is not 
 a function type

Same as {\tt{Cil.splitFunctionType}}[\ref{val:Cil.splitFunctionType}] but takes a varinfo. Prints a nicer 
 error message if the varinfo is not for a function


\end{ocamldocdescription}




\label{val:Cil.splitFunctionTypeVI}\begin{ocamldoccode}
val splitFunctionTypeVI :
  varinfo ->
  typ * (string * typ * attributes) list option * bool *
  attributes
\end{ocamldoccode}
\index{splitFunctionTypeVI@\verb`splitFunctionTypeVI`}




{\bf Type signatures}



Type signatures. Two types are identical iff they have identical 
 signatures. These contain the same information as types but canonicalized. 
 For example, two function types that are identical except for the name of 
 the formal arguments are given the same signature. Also, {\tt{TNamed}} 
 constructors are unrolled.



\label{val:Cil.d-underscoretypsig}\begin{ocamldoccode}
val d_typsig : unit -> typsig -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoretypsig@\verb`d_typsig`}
\begin{ocamldocdescription}
Print a type signature


\end{ocamldocdescription}




\label{val:Cil.typeSig}\begin{ocamldoccode}
val typeSig : typ -> typsig
\end{ocamldoccode}
\index{typeSig@\verb`typeSig`}
\begin{ocamldocdescription}
Compute a type signature


\end{ocamldocdescription}




\label{val:Cil.typeSigWithAttrs}\begin{ocamldoccode}
val typeSigWithAttrs :
  ?ignoreSign:bool ->
  (attributes -> attributes) -> typ -> typsig
\end{ocamldoccode}
\index{typeSigWithAttrs@\verb`typeSigWithAttrs`}
\begin{ocamldocdescription}
Like {\tt{Cil.typeSig}}[\ref{val:Cil.typeSig}] but customize the incorporation of attributes.
    Use \~{}ignoreSign:true to convert all signed integer types to unsigned,
    so that signed and unsigned will compare the same.


\end{ocamldocdescription}




\label{val:Cil.setTypeSigAttrs}\begin{ocamldoccode}
val setTypeSigAttrs : attributes -> typsig -> typsig
\end{ocamldoccode}
\index{setTypeSigAttrs@\verb`setTypeSigAttrs`}
\begin{ocamldocdescription}
Replace the attributes of a signature (only at top level)


\end{ocamldocdescription}




\label{val:Cil.typeSigAttrs}\begin{ocamldoccode}
val typeSigAttrs : typsig -> attributes
\end{ocamldoccode}
\index{typeSigAttrs@\verb`typeSigAttrs`}
\begin{ocamldocdescription}
Get the top-level attributes of a signature


\end{ocamldocdescription}




{\bf Lvalues}



\label{val:Cil.makeVarinfo}\begin{ocamldoccode}
val makeVarinfo : bool -> string -> typ -> varinfo
\end{ocamldoccode}
\index{makeVarinfo@\verb`makeVarinfo`}
\begin{ocamldocdescription}
Make a varinfo. Use this (rarely) to make a raw varinfo. Use other 
 functions to make locals ({\tt{Cil.makeLocalVar}}[\ref{val:Cil.makeLocalVar}] or {\tt{Cil.makeFormalVar}}[\ref{val:Cil.makeFormalVar}] or 
 {\tt{Cil.makeTempVar}}[\ref{val:Cil.makeTempVar}]) and globals ({\tt{Cil.makeGlobalVar}}[\ref{val:Cil.makeGlobalVar}]). Note that this 
 function will assign a new identifier. The first argument specifies 
 whether the varinfo is for a global.


\end{ocamldocdescription}




\label{val:Cil.makeFormalVar}\begin{ocamldoccode}
val makeFormalVar : fundec -> ?where:string -> string -> typ -> varinfo
\end{ocamldoccode}
\index{makeFormalVar@\verb`makeFormalVar`}
\begin{ocamldocdescription}
Make a formal variable for a function. Insert it in both the sformals 
    and the type of the function. You can optionally specify where to insert 
    this one. If where $=$ "\textasciicircum " then it is inserted first. If where $=$ "\$" then 
    it is inserted last. Otherwise where must be the name of a formal after 
    which to insert this. By default it is inserted at the end.


\end{ocamldocdescription}




\label{val:Cil.makeLocalVar}\begin{ocamldoccode}
val makeLocalVar : fundec -> ?insert:bool -> string -> typ -> varinfo
\end{ocamldoccode}
\index{makeLocalVar@\verb`makeLocalVar`}
\begin{ocamldocdescription}
Make a local variable and add it to a function's slocals (only if insert $=$ 
    true, which is the default). Make sure you know what you are doing if you 
    set insert$=$false.


\end{ocamldocdescription}




\label{val:Cil.makeTempVar}\begin{ocamldoccode}
val makeTempVar :
  fundec ->
  ?insert:bool ->
  ?name:string ->
  ?descr:Pretty.doc -> ?descrpure:bool -> typ -> varinfo
\end{ocamldoccode}
\index{makeTempVar@\verb`makeTempVar`}
\begin{ocamldocdescription}
Make a temporary variable and add it to a function's slocals. CIL will
    ensure that the name of the new variable is unique in this function, and
    will generate this name by appending a number to the specified string
    ("\_\_cil\_tmp" by default).


    The variable will be added to the function's slocals unless you explicitly
    set insert$=$false.  (Make sure you know what you are doing if you set
    insert$=$false.)


    Optionally, you can give the variable a description of its contents
    that will be printed by descriptiveCilPrinter.


\end{ocamldocdescription}




\label{val:Cil.makeGlobalVar}\begin{ocamldoccode}
val makeGlobalVar : string -> typ -> varinfo
\end{ocamldoccode}
\index{makeGlobalVar@\verb`makeGlobalVar`}
\begin{ocamldocdescription}
Make a global variable. Your responsibility to make sure that the name 
    is unique


\end{ocamldocdescription}




\label{val:Cil.copyVarinfo}\begin{ocamldoccode}
val copyVarinfo : varinfo -> string -> varinfo
\end{ocamldoccode}
\index{copyVarinfo@\verb`copyVarinfo`}
\begin{ocamldocdescription}
Make a shallow copy of a {\tt{varinfo}} and assign a new identifier


\end{ocamldocdescription}




\label{val:Cil.newVID}\begin{ocamldoccode}
val newVID : unit -> int
\end{ocamldoccode}
\index{newVID@\verb`newVID`}
\begin{ocamldocdescription}
Generate a new variable ID. This will be different than any variable ID 
 that is generated by {\tt{Cil.makeLocalVar}}[\ref{val:Cil.makeLocalVar}] and friends


\end{ocamldocdescription}




\label{val:Cil.addOffsetLval}\begin{ocamldoccode}
val addOffsetLval : offset -> lval -> lval
\end{ocamldoccode}
\index{addOffsetLval@\verb`addOffsetLval`}
\begin{ocamldocdescription}
Add an offset at the end of an lvalue. Make sure the type of the lvalue 
 and the offset are compatible.


\end{ocamldocdescription}




\label{val:Cil.addOffset}\begin{ocamldoccode}
val addOffset : offset -> offset -> offset
\end{ocamldoccode}
\index{addOffset@\verb`addOffset`}
\begin{ocamldocdescription}
{\tt{addOffset o1 o2}} adds {\tt{o1}} to the end of {\tt{o2}}.


\end{ocamldocdescription}




\label{val:Cil.removeOffsetLval}\begin{ocamldoccode}
val removeOffsetLval : lval -> lval * offset
\end{ocamldoccode}
\index{removeOffsetLval@\verb`removeOffsetLval`}
\begin{ocamldocdescription}
Remove ONE offset from the end of an lvalue. Returns the lvalue with the 
 trimmed offset and the final offset. If the final offset is {\tt{NoOffset}} 
 then the original {\tt{lval}} did not have an offset.


\end{ocamldocdescription}




\label{val:Cil.removeOffset}\begin{ocamldoccode}
val removeOffset : offset -> offset * offset
\end{ocamldoccode}
\index{removeOffset@\verb`removeOffset`}
\begin{ocamldocdescription}
Remove ONE offset from the end of an offset sequence. Returns the 
 trimmed offset and the final offset. If the final offset is {\tt{NoOffset}} 
 then the original {\tt{lval}} did not have an offset.


\end{ocamldocdescription}




\label{val:Cil.typeOfLval}\begin{ocamldoccode}
val typeOfLval : lval -> typ
\end{ocamldoccode}
\index{typeOfLval@\verb`typeOfLval`}
\begin{ocamldocdescription}
Compute the type of an lvalue


\end{ocamldocdescription}




\label{val:Cil.typeOffset}\begin{ocamldoccode}
val typeOffset : typ -> offset -> typ
\end{ocamldoccode}
\index{typeOffset@\verb`typeOffset`}
\begin{ocamldocdescription}
Compute the type of an offset from a base type


\end{ocamldocdescription}




{\bf Values for manipulating expressions}



\label{val:Cil.zero}\begin{ocamldoccode}
val zero : exp
\end{ocamldoccode}
\index{zero@\verb`zero`}
\begin{ocamldocdescription}
0


\end{ocamldocdescription}




\label{val:Cil.one}\begin{ocamldoccode}
val one : exp
\end{ocamldoccode}
\index{one@\verb`one`}
\begin{ocamldocdescription}
1


\end{ocamldocdescription}




\label{val:Cil.mone}\begin{ocamldoccode}
val mone : exp
\end{ocamldoccode}
\index{mone@\verb`mone`}
\begin{ocamldocdescription}
-1


\end{ocamldocdescription}




\label{val:Cil.kintegerCilint}\begin{ocamldoccode}
val kintegerCilint : ikind -> Cilint.cilint -> exp
\end{ocamldoccode}
\index{kintegerCilint@\verb`kintegerCilint`}
\begin{ocamldocdescription}
Construct an integer of a given kind, from a cilint. If needed it
 will truncate the integer to be within the representable range for
 the given kind.


\end{ocamldocdescription}




\label{val:Cil.kinteger64}\begin{ocamldoccode}
val kinteger64 : ikind -> int64 -> exp
\end{ocamldoccode}
\index{kinteger64@\verb`kinteger64`}
\begin{ocamldocdescription}
Construct an integer of a given kind, using OCaml's int64 type. If needed 
 it will truncate the integer to be within the representable range for the 
 given kind.


\end{ocamldocdescription}




\label{val:Cil.kinteger}\begin{ocamldoccode}
val kinteger : ikind -> int -> exp
\end{ocamldoccode}
\index{kinteger@\verb`kinteger`}
\begin{ocamldocdescription}
Construct an integer of a given kind. Converts the integer to int64 and 
 then uses kinteger64. This might truncate the value if you use a kind 
 that cannot represent the given integer. This can only happen for one of 
 the Char or Short kinds


\end{ocamldocdescription}




\label{val:Cil.integer}\begin{ocamldoccode}
val integer : int -> exp
\end{ocamldoccode}
\index{integer@\verb`integer`}
\begin{ocamldocdescription}
Construct an integer of kind IInt. On targets where C's 'int' is 16-bits,
    the integer may get truncated.


\end{ocamldocdescription}




\label{val:Cil.getInteger}\begin{ocamldoccode}
val getInteger : exp -> Cilint.cilint option
\end{ocamldoccode}
\index{getInteger@\verb`getInteger`}
\begin{ocamldocdescription}
If the given expression is an integer constant or a CastE'd
    integer constant, return that constant's value. 
    Otherwise return None.


\end{ocamldocdescription}




\label{val:Cil.i64-underscoreto-underscoreint}\begin{ocamldoccode}
val i64_to_int : int64 -> int
\end{ocamldoccode}
\index{i64-underscoreto-underscoreint@\verb`i64_to_int`}
\begin{ocamldocdescription}
Convert a 64-bit int to an OCaml int, or raise an exception if that
    can't be done.


\end{ocamldocdescription}




\label{val:Cil.cilint-underscoreto-underscoreint}\begin{ocamldoccode}
val cilint_to_int : Cilint.cilint -> int
\end{ocamldoccode}
\index{cilint-underscoreto-underscoreint@\verb`cilint_to_int`}
\begin{ocamldocdescription}
Convert a cilint int to an OCaml int, or raise an exception if that
    can't be done.


\end{ocamldocdescription}




\label{val:Cil.isConstant}\begin{ocamldoccode}
val isConstant : exp -> bool
\end{ocamldoccode}
\index{isConstant@\verb`isConstant`}
\begin{ocamldocdescription}
True if the expression is a compile-time constant


\end{ocamldocdescription}




\label{val:Cil.isConstantOffset}\begin{ocamldoccode}
val isConstantOffset : offset -> bool
\end{ocamldoccode}
\index{isConstantOffset@\verb`isConstantOffset`}
\begin{ocamldocdescription}
True if the given offset contains only field nanmes or constant indices.


\end{ocamldocdescription}




\label{val:Cil.isZero}\begin{ocamldoccode}
val isZero : exp -> bool
\end{ocamldoccode}
\index{isZero@\verb`isZero`}
\begin{ocamldocdescription}
True if the given expression is a (possibly cast'ed) integer or character 
    constant with value zero


\end{ocamldocdescription}




\label{val:Cil.charConstToInt}\begin{ocamldoccode}
val charConstToInt : char -> constant
\end{ocamldoccode}
\index{charConstToInt@\verb`charConstToInt`}
\begin{ocamldocdescription}
Given the character c in a (CChr c), sign-extend it to 32 bits.
  (This is the official way of interpreting character constants, according to
  ISO C 6.4.4.4.10, which says that character constants are chars cast to ints)
  Returns CInt64(sign-extened c, IInt, None)


\end{ocamldocdescription}




\label{val:Cil.constFold}\begin{ocamldoccode}
val constFold : bool -> exp -> exp
\end{ocamldoccode}
\index{constFold@\verb`constFold`}
\begin{ocamldocdescription}
Do constant folding on an expression. If the first argument is true then 
    will also compute compiler-dependent expressions such as sizeof.
    See also {\tt{Cil.constFoldVisitor}}[\ref{val:Cil.constFoldVisitor}], which will run constFold on all
    expressions in a given AST node.


\end{ocamldocdescription}




\label{val:Cil.constFoldBinOp}\begin{ocamldoccode}
val constFoldBinOp : bool -> binop -> exp -> exp -> typ -> exp
\end{ocamldoccode}
\index{constFoldBinOp@\verb`constFoldBinOp`}
\begin{ocamldocdescription}
Do constant folding on a binary operation. The bulk of the work done by 
    {\tt{constFold}} is done here. If the first argument is true then 
    will also compute compiler-dependent expressions such as sizeof


\end{ocamldocdescription}




\label{val:Cil.increm}\begin{ocamldoccode}
val increm : exp -> int -> exp
\end{ocamldoccode}
\index{increm@\verb`increm`}
\begin{ocamldocdescription}
Increment an expression. Can be arithmetic or pointer type


\end{ocamldocdescription}




\label{val:Cil.var}\begin{ocamldoccode}
val var : varinfo -> lval
\end{ocamldoccode}
\index{var@\verb`var`}
\begin{ocamldocdescription}
Makes an lvalue out of a given variable


\end{ocamldocdescription}




\label{val:Cil.mkAddrOf}\begin{ocamldoccode}
val mkAddrOf : lval -> exp
\end{ocamldoccode}
\index{mkAddrOf@\verb`mkAddrOf`}
\begin{ocamldocdescription}
Make an AddrOf. Given an lvalue of type T will give back an expression of 
    type ptr(T). It optimizes somewhat expressions like "\& v" and "\& v{\tt{0}}"


\end{ocamldocdescription}




\label{val:Cil.mkAddrOrStartOf}\begin{ocamldoccode}
val mkAddrOrStartOf : lval -> exp
\end{ocamldoccode}
\index{mkAddrOrStartOf@\verb`mkAddrOrStartOf`}
\begin{ocamldocdescription}
Like mkAddrOf except if the type of lval is an array then it uses 
    StartOf. This is the right operation for getting a pointer to the start 
    of the storage denoted by lval.


\end{ocamldocdescription}




\label{val:Cil.mkMem}\begin{ocamldoccode}
val mkMem : addr:exp -> off:offset -> lval
\end{ocamldoccode}
\index{mkMem@\verb`mkMem`}
\begin{ocamldocdescription}
Make a Mem, while optimizing AddrOf. The type of the addr must be 
    TPtr(t) and the type of the resulting lval is t. Note that in CIL the 
    implicit conversion between an array and the pointer to the first 
    element does not apply. You must do the conversion yourself using 
    StartOf


\end{ocamldocdescription}




\label{val:Cil.mkString}\begin{ocamldoccode}
val mkString : string -> exp
\end{ocamldoccode}
\index{mkString@\verb`mkString`}
\begin{ocamldocdescription}
Make an expression that is a string constant (of pointer type)


\end{ocamldocdescription}




\label{val:Cil.mkCastT}\begin{ocamldoccode}
val mkCastT : e:exp -> oldt:typ -> newt:typ -> exp
\end{ocamldoccode}
\index{mkCastT@\verb`mkCastT`}
\begin{ocamldocdescription}
Construct a cast when having the old type of the expression. If the new 
 type is the same as the old type, then no cast is added.


\end{ocamldocdescription}




\label{val:Cil.mkCast}\begin{ocamldoccode}
val mkCast : e:exp -> newt:typ -> exp
\end{ocamldoccode}
\index{mkCast@\verb`mkCast`}
\begin{ocamldocdescription}
Like {\tt{Cil.mkCastT}}[\ref{val:Cil.mkCastT}] but uses typeOf to get {\tt{oldt}}


\end{ocamldocdescription}




\label{val:Cil.stripCasts}\begin{ocamldoccode}
val stripCasts : exp -> exp
\end{ocamldoccode}
\index{stripCasts@\verb`stripCasts`}
\begin{ocamldocdescription}
Removes casts from this expression, but ignores casts within
  other expression constructs.  So we delete the (A) and (B) casts from 
  "(A)(B)(x + (C)y)", but leave the (C) cast.


\end{ocamldocdescription}




\label{val:Cil.typeOf}\begin{ocamldoccode}
val typeOf : exp -> typ
\end{ocamldoccode}
\index{typeOf@\verb`typeOf`}
\begin{ocamldocdescription}
Compute the type of an expression


\end{ocamldocdescription}




\label{val:Cil.parseInt}\begin{ocamldoccode}
val parseInt : string -> exp
\end{ocamldoccode}
\index{parseInt@\verb`parseInt`}
\begin{ocamldocdescription}
Convert a string representing a C integer literal to an expression. 
 Handles the prefixes 0x and 0 and the suffixes L, U, UL, LL, ULL


\end{ocamldocdescription}




{\bf Values for manipulating statements}



\label{val:Cil.mkStmt}\begin{ocamldoccode}
val mkStmt : stmtkind -> stmt
\end{ocamldoccode}
\index{mkStmt@\verb`mkStmt`}
\begin{ocamldocdescription}
Construct a statement, given its kind. Initialize the {\tt{sid}} field to -1,
    and {\tt{labels}}, {\tt{succs}} and {\tt{preds}} to the empty list


\end{ocamldocdescription}




\label{val:Cil.mkBlock}\begin{ocamldoccode}
val mkBlock : stmt list -> block
\end{ocamldoccode}
\index{mkBlock@\verb`mkBlock`}
\begin{ocamldocdescription}
Construct a block with no attributes, given a list of statements


\end{ocamldocdescription}




\label{val:Cil.mkStmtOneInstr}\begin{ocamldoccode}
val mkStmtOneInstr : instr -> stmt
\end{ocamldoccode}
\index{mkStmtOneInstr@\verb`mkStmtOneInstr`}
\begin{ocamldocdescription}
Construct a statement consisting of just one instruction


\end{ocamldocdescription}




\label{val:Cil.compactStmts}\begin{ocamldoccode}
val compactStmts : stmt list -> stmt list
\end{ocamldoccode}
\index{compactStmts@\verb`compactStmts`}
\begin{ocamldocdescription}
Try to compress statements so as to get maximal basic blocks.
 use this instead of List.@ because you get fewer basic blocks


\end{ocamldocdescription}




\label{val:Cil.mkEmptyStmt}\begin{ocamldoccode}
val mkEmptyStmt : unit -> stmt
\end{ocamldoccode}
\index{mkEmptyStmt@\verb`mkEmptyStmt`}
\begin{ocamldocdescription}
Returns an empty statement (of kind {\tt{Instr}})


\end{ocamldocdescription}




\label{val:Cil.dummyInstr}\begin{ocamldoccode}
val dummyInstr : instr
\end{ocamldoccode}
\index{dummyInstr@\verb`dummyInstr`}
\begin{ocamldocdescription}
A instr to serve as a placeholder


\end{ocamldocdescription}




\label{val:Cil.dummyStmt}\begin{ocamldoccode}
val dummyStmt : stmt
\end{ocamldoccode}
\index{dummyStmt@\verb`dummyStmt`}
\begin{ocamldocdescription}
A statement consisting of just {\tt{dummyInstr}}


\end{ocamldocdescription}




\label{val:Cil.mkWhile}\begin{ocamldoccode}
val mkWhile : guard:exp -> body:stmt list -> stmt list
\end{ocamldoccode}
\index{mkWhile@\verb`mkWhile`}
\begin{ocamldocdescription}
Make a while loop. Can contain Break or Continue


\end{ocamldocdescription}




\label{val:Cil.mkForIncr}\begin{ocamldoccode}
val mkForIncr :
  iter:varinfo ->
  first:exp ->
  stopat:exp -> incr:exp -> body:stmt list -> stmt list
\end{ocamldoccode}
\index{mkForIncr@\verb`mkForIncr`}
\begin{ocamldocdescription}
Make a for loop for(i$=$start; i$<$past; i +$=$ incr) \{ $\ldots$ \}. The body 
    can contain Break but not Continue. Can be used with i a pointer 
    or an integer. Start and done must have the same type but incr 
    must be an integer


\end{ocamldocdescription}




\label{val:Cil.mkFor}\begin{ocamldoccode}
val mkFor :
  start:stmt list ->
  guard:exp -> next:stmt list -> body:stmt list -> stmt list
\end{ocamldoccode}
\index{mkFor@\verb`mkFor`}
\begin{ocamldocdescription}
Make a for loop for(start; guard; next) \{ $\ldots$ \}. The body can 
    contain Break but not Continue !!!


\end{ocamldocdescription}




{\bf Values for manipulating attributes}



\label{type:Cil.attributeClass}\begin{ocamldoccode}
type attributeClass =
  | AttrName of bool
\end{ocamldoccode}
\begin{ocamldoccomment}
Attribute of a name. If argument is true and we are on MSVC then 
            the attribute is printed using \_\_declspec as part of the storage 
            specifier
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AttrFunType of bool
\end{ocamldoccode}
\begin{ocamldoccomment}
Attribute of a function type. If argument is true and we are on 
            MSVC then the attribute is printed just before the function name
\end{ocamldoccomment}
\begin{ocamldoccode}
  | AttrType
\end{ocamldoccode}
\begin{ocamldoccomment}
Attribute of a type
\end{ocamldoccomment}
\index{attributeClass@\verb`attributeClass`}
\begin{ocamldocdescription}
Various classes of attributes


\end{ocamldocdescription}




\label{val:Cil.attributeHash}\begin{ocamldoccode}
val attributeHash : (string, attributeClass) Hashtbl.t
\end{ocamldoccode}
\index{attributeHash@\verb`attributeHash`}
\begin{ocamldocdescription}
This table contains the mapping of predefined attributes to classes. 
    Extend this table with more attributes as you need. This table is used to 
    determine how to associate attributes with names or types


\end{ocamldocdescription}




\label{val:Cil.partitionAttributes}\begin{ocamldoccode}
val partitionAttributes :
  default:attributeClass ->
  attributes ->
  attribute list * attribute list * attribute list
\end{ocamldoccode}
\index{partitionAttributes@\verb`partitionAttributes`}
\begin{ocamldocdescription}
Partition the attributes into classes:name attributes, function type, 
    and type attributes


\end{ocamldocdescription}




\label{val:Cil.addAttribute}\begin{ocamldoccode}
val addAttribute : attribute -> attributes -> attributes
\end{ocamldoccode}
\index{addAttribute@\verb`addAttribute`}
\begin{ocamldocdescription}
Add an attribute. Maintains the attributes in sorted order of the second 
    argument


\end{ocamldocdescription}




\label{val:Cil.addAttributes}\begin{ocamldoccode}
val addAttributes : attribute list -> attributes -> attributes
\end{ocamldoccode}
\index{addAttributes@\verb`addAttributes`}
\begin{ocamldocdescription}
Add a list of attributes. Maintains the attributes in sorted order. The 
    second argument must be sorted, but not necessarily the first


\end{ocamldocdescription}




\label{val:Cil.dropAttribute}\begin{ocamldoccode}
val dropAttribute : string -> attributes -> attributes
\end{ocamldoccode}
\index{dropAttribute@\verb`dropAttribute`}
\begin{ocamldocdescription}
Remove all attributes with the given name. Maintains the attributes in 
    sorted order.


\end{ocamldocdescription}




\label{val:Cil.dropAttributes}\begin{ocamldoccode}
val dropAttributes : string list -> attributes -> attributes
\end{ocamldoccode}
\index{dropAttributes@\verb`dropAttributes`}
\begin{ocamldocdescription}
Remove all attributes with names appearing in the string list.
  Maintains the attributes in sorted order


\end{ocamldocdescription}




\label{val:Cil.filterAttributes}\begin{ocamldoccode}
val filterAttributes : string -> attributes -> attributes
\end{ocamldoccode}
\index{filterAttributes@\verb`filterAttributes`}
\begin{ocamldocdescription}
Retains attributes with the given name


\end{ocamldocdescription}




\label{val:Cil.hasAttribute}\begin{ocamldoccode}
val hasAttribute : string -> attributes -> bool
\end{ocamldoccode}
\index{hasAttribute@\verb`hasAttribute`}
\begin{ocamldocdescription}
True if the named attribute appears in the attribute list. The list of
    attributes must be sorted.


\end{ocamldocdescription}




\label{val:Cil.typeAttrs}\begin{ocamldoccode}
val typeAttrs : typ -> attribute list
\end{ocamldoccode}
\index{typeAttrs@\verb`typeAttrs`}
\begin{ocamldocdescription}
Returns all the attributes contained in a type. This requires a traversal 
    of the type structure, in case of composite, enumeration and named types


\end{ocamldocdescription}




\label{val:Cil.setTypeAttrs}\begin{ocamldoccode}
val setTypeAttrs : typ -> attributes -> typ
\end{ocamldoccode}
\index{setTypeAttrs@\verb`setTypeAttrs`}




\label{val:Cil.typeAddAttributes}\begin{ocamldoccode}
val typeAddAttributes : attribute list -> typ -> typ
\end{ocamldoccode}
\index{typeAddAttributes@\verb`typeAddAttributes`}
\begin{ocamldocdescription}
Add some attributes to a type


\end{ocamldocdescription}




\label{val:Cil.typeRemoveAttributes}\begin{ocamldoccode}
val typeRemoveAttributes : string list -> typ -> typ
\end{ocamldoccode}
\index{typeRemoveAttributes@\verb`typeRemoveAttributes`}
\begin{ocamldocdescription}
Remove all attributes with the given names from a type. Note that this
    does not remove attributes from typedef and tag definitions, just from 
    their uses


\end{ocamldocdescription}




\label{val:Cil.expToAttrParam}\begin{ocamldoccode}
val expToAttrParam : exp -> attrparam
\end{ocamldoccode}
\index{expToAttrParam@\verb`expToAttrParam`}
\begin{ocamldocdescription}
Convert an expression into an attrparam, if possible. Otherwise raise
    NotAnAttrParam with the offending subexpression


\end{ocamldocdescription}




\label{exception:Cil.NotAnAttrParam}\begin{ocamldoccode}
exception NotAnAttrParam of exp
\end{ocamldoccode}
\index{NotAnAttrParam@\verb`NotAnAttrParam`}




{\bf The visitor}



\label{type:Cil.visitAction}\begin{ocamldoccode}
type 'a visitAction =
  | SkipChildren
\end{ocamldoccode}
\begin{ocamldoccomment}
Do not visit the children. Return 
                                            the node as it is.
\end{ocamldoccomment}
\begin{ocamldoccode}
  | DoChildren
\end{ocamldoccode}
\begin{ocamldoccomment}
Continue with the children of this 
                                            node. Rebuild the node on return 
                                            if any of the children changes 
                                            (use $=$$=$ test)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ChangeTo of 'a
\end{ocamldoccode}
\begin{ocamldoccomment}
Replace the expression with the 
                                            given one
\end{ocamldoccomment}
\begin{ocamldoccode}
  | ChangeDoChildrenPost of 'a * ('a -> 'a)
\end{ocamldoccode}
\begin{ocamldoccomment}
First consider that the entire 
                                           exp is replaced by the first 
                                           parameter. Then continue with 
                                           the children. On return rebuild 
                                           the node if any of the children 
                                           has changed and then apply the 
                                           function on the node
\end{ocamldoccomment}
\index{visitAction@\verb`visitAction`}
\begin{ocamldocdescription}
Different visiting actions. 'a will be instantiated with {\tt{exp}}, {\tt{instr}},
    etc.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{class type cilVisitor = }}\end{ocamldoccode}
\label{classtype:Cil.cilVisitor}\index{cilVisitor@\verb`cilVisitor`}

\begin{ocamldocobjectend}


\label{method:Cil.cilVisitor.vvdec}\begin{ocamldoccode}
method vvdec : Cil.varinfo -> Cil.varinfo Cil.visitAction
\end{ocamldoccode}
\index{vvdec@\verb`vvdec`}
\begin{ocamldocdescription}
Invoked for each variable declaration. The subtrees to be traversed 
 are those corresponding to the type and attributes of the variable. 
 Note that variable declarations are all the {\tt{GVar}}, {\tt{GVarDecl}}, {\tt{GFun}}, 
 all the {\tt{varinfo}} in formals of function types, and the formals and 
 locals for function definitions. This means that the list of formals 
 in a function definition will be traversed twice, once as part of the 
 function type and second as part of the formals in a function 
 definition.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vvrbl}\begin{ocamldoccode}
method vvrbl : Cil.varinfo -> Cil.varinfo Cil.visitAction
\end{ocamldoccode}
\index{vvrbl@\verb`vvrbl`}
\begin{ocamldocdescription}
Invoked on each variable use. Here only the {\tt{SkipChildren}} and 
 {\tt{ChangeTo}} actions make sense since there are no subtrees. Note that 
 the type and attributes of the variable are not traversed for a 
 variable use


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vexpr}\begin{ocamldoccode}
method vexpr : Cil.exp -> Cil.exp Cil.visitAction
\end{ocamldoccode}
\index{vexpr@\verb`vexpr`}
\begin{ocamldocdescription}
Invoked on each expression occurrence. The subtrees are the 
 subexpressions, the types (for a {\tt{Cast}} or {\tt{SizeOf}} expression) or the 
 variable use.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vlval}\begin{ocamldoccode}
method vlval : Cil.lval -> Cil.lval Cil.visitAction
\end{ocamldoccode}
\index{vlval@\verb`vlval`}
\begin{ocamldocdescription}
Invoked on each lvalue occurrence


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.voffs}\begin{ocamldoccode}
method voffs : Cil.offset -> Cil.offset Cil.visitAction
\end{ocamldoccode}
\index{voffs@\verb`voffs`}
\begin{ocamldocdescription}
Invoked on each offset occurrence that is *not* as part
 of an initializer list specification, i.e. in an lval or
 recursively inside an offset.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vinitoffs}\begin{ocamldoccode}
method vinitoffs : Cil.offset -> Cil.offset Cil.visitAction
\end{ocamldoccode}
\index{vinitoffs@\verb`vinitoffs`}
\begin{ocamldocdescription}
Invoked on each offset appearing in the list of a 
 CompoundInit initializer.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vinst}\begin{ocamldoccode}
method vinst : Cil.instr -> Cil.instr list Cil.visitAction
\end{ocamldoccode}
\index{vinst@\verb`vinst`}
\begin{ocamldocdescription}
Invoked on each instruction occurrence. The {\tt{ChangeTo}} action can
 replace this instruction with a list of instructions


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vstmt}\begin{ocamldoccode}
method vstmt : Cil.stmt -> Cil.stmt Cil.visitAction
\end{ocamldoccode}
\index{vstmt@\verb`vstmt`}
\begin{ocamldocdescription}
Control-flow statement. The default {\tt{DoChildren}} action does not 
 create a new statement when the components change. Instead it updates 
 the contents of the original statement. This is done to preserve the 
 sharing with {\tt{Goto}} and {\tt{Case}} statements that point to the original 
 statement. If you use the {\tt{ChangeTo}} action then you should take care 
 of preserving that sharing yourself.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vblock}\begin{ocamldoccode}
method vblock : Cil.block -> Cil.block Cil.visitAction
\end{ocamldoccode}
\index{vblock@\verb`vblock`}
\begin{ocamldocdescription}
Block.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vfunc}\begin{ocamldoccode}
method vfunc : Cil.fundec -> Cil.fundec Cil.visitAction
\end{ocamldoccode}
\index{vfunc@\verb`vfunc`}
\begin{ocamldocdescription}
Function definition. 
                                                    Replaced in place.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vglob}\begin{ocamldoccode}
method vglob : Cil.global -> Cil.global list Cil.visitAction
\end{ocamldoccode}
\index{vglob@\verb`vglob`}
\begin{ocamldocdescription}
Global (vars, types,
                                                      etc.)


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vinit}\begin{ocamldoccode}
method vinit :
  Cil.varinfo -> Cil.offset -> Cil.init -> Cil.init Cil.visitAction
\end{ocamldoccode}
\index{vinit@\verb`vinit`}
\begin{ocamldocdescription}
Initializers for globals, 
 pass the global where this 
 occurs, and the offset


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vtype}\begin{ocamldoccode}
method vtype : Cil.typ -> Cil.typ Cil.visitAction
\end{ocamldoccode}
\index{vtype@\verb`vtype`}
\begin{ocamldocdescription}
Use of some type. Note 
 that for structure/union 
 and enumeration types the 
 definition of the 
 composite type is not 
 visited. Use {\tt{vglob}} to 
 visit it.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vattr}\begin{ocamldoccode}
method vattr : Cil.attribute -> Cil.attribute list Cil.visitAction
\end{ocamldoccode}
\index{vattr@\verb`vattr`}
\begin{ocamldocdescription}
Attribute. Each attribute can be replaced by a list


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.vattrparam}\begin{ocamldoccode}
method vattrparam : Cil.attrparam -> Cil.attrparam Cil.visitAction
\end{ocamldoccode}
\index{vattrparam@\verb`vattrparam`}
\begin{ocamldocdescription}
Attribute parameters.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.queueInstr}\begin{ocamldoccode}
method queueInstr : Cil.instr list -> unit
\end{ocamldoccode}
\index{queueInstr@\verb`queueInstr`}
\begin{ocamldocdescription}
Add here instructions while visiting to queue them to preceede the 
 current statement or instruction being processed. Use this method only 
 when you are visiting an expression that is inside a function body, or 
 a statement, because otherwise there will no place for the visitor to 
 place your instructions.


\end{ocamldocdescription}


\label{method:Cil.cilVisitor.unqueueInstr}\begin{ocamldoccode}
method unqueueInstr : unit -> Cil.instr list
\end{ocamldoccode}
\index{unqueueInstr@\verb`unqueueInstr`}
\begin{ocamldocdescription}
Gets the queue of instructions and resets the queue. This is done 
 automatically for you when you visit statments.


\end{ocamldocdescription}
\end{ocamldocobjectend}


\begin{ocamldocdescription}
A visitor interface for traversing CIL trees. Create instantiations of 
 this type by specializing the class {\tt{Cil.nopCilVisitor}}[\ref{class:Cil.nopCilVisitor}]. Each of the 
 specialized visiting functions can also call the {\tt{queueInstr}} to specify 
 that some instructions should be inserted before the current instruction 
 or statement. Use syntax like {\tt{self\verb`#`queueInstr}} to call a method
 associated with the current object.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{class nopCilVisitor : }}{\tt{cilVisitor}}\end{ocamldoccode}
\label{class:Cil.nopCilVisitor}\index{nopCilVisitor@\verb`nopCilVisitor`}



\begin{ocamldocdescription}
Default Visitor. Traverses the CIL tree without modifying anything


\end{ocamldocdescription}




\label{val:Cil.visitCilFile}\begin{ocamldoccode}
val visitCilFile : cilVisitor -> file -> unit
\end{ocamldoccode}
\index{visitCilFile@\verb`visitCilFile`}
\begin{ocamldocdescription}
Visit a file. This will will re-cons all globals TWICE (so that it is 
 tail-recursive). Use {\tt{Cil.visitCilFileSameGlobals}}[\ref{val:Cil.visitCilFileSameGlobals}] if your visitor will 
 not change the list of globals.


\end{ocamldocdescription}




\label{val:Cil.visitCilFileSameGlobals}\begin{ocamldoccode}
val visitCilFileSameGlobals : cilVisitor -> file -> unit
\end{ocamldoccode}
\index{visitCilFileSameGlobals@\verb`visitCilFileSameGlobals`}
\begin{ocamldocdescription}
A visitor for the whole file that does not change the globals (but maybe
 changes things inside the globals). Use this function instead of
 {\tt{Cil.visitCilFile}}[\ref{val:Cil.visitCilFile}] whenever appropriate because it is more efficient for
 long files.


\end{ocamldocdescription}




\label{val:Cil.visitCilGlobal}\begin{ocamldoccode}
val visitCilGlobal : cilVisitor -> global -> global list
\end{ocamldoccode}
\index{visitCilGlobal@\verb`visitCilGlobal`}
\begin{ocamldocdescription}
Visit a global


\end{ocamldocdescription}




\label{val:Cil.visitCilFunction}\begin{ocamldoccode}
val visitCilFunction : cilVisitor -> fundec -> fundec
\end{ocamldoccode}
\index{visitCilFunction@\verb`visitCilFunction`}
\begin{ocamldocdescription}
Visit a function definition


\end{ocamldocdescription}




\label{val:Cil.visitCilExpr}\begin{ocamldoccode}
val visitCilExpr : cilVisitor -> exp -> exp
\end{ocamldoccode}
\index{visitCilExpr@\verb`visitCilExpr`}




\label{val:Cil.visitCilLval}\begin{ocamldoccode}
val visitCilLval : cilVisitor -> lval -> lval
\end{ocamldoccode}
\index{visitCilLval@\verb`visitCilLval`}
\begin{ocamldocdescription}
Visit an lvalue


\end{ocamldocdescription}




\label{val:Cil.visitCilOffset}\begin{ocamldoccode}
val visitCilOffset : cilVisitor -> offset -> offset
\end{ocamldoccode}
\index{visitCilOffset@\verb`visitCilOffset`}
\begin{ocamldocdescription}
Visit an lvalue or recursive offset


\end{ocamldocdescription}




\label{val:Cil.visitCilInitOffset}\begin{ocamldoccode}
val visitCilInitOffset : cilVisitor -> offset -> offset
\end{ocamldoccode}
\index{visitCilInitOffset@\verb`visitCilInitOffset`}
\begin{ocamldocdescription}
Visit an initializer offset


\end{ocamldocdescription}




\label{val:Cil.visitCilInstr}\begin{ocamldoccode}
val visitCilInstr : cilVisitor -> instr -> instr list
\end{ocamldoccode}
\index{visitCilInstr@\verb`visitCilInstr`}
\begin{ocamldocdescription}
Visit an instruction


\end{ocamldocdescription}




\label{val:Cil.visitCilStmt}\begin{ocamldoccode}
val visitCilStmt : cilVisitor -> stmt -> stmt
\end{ocamldoccode}
\index{visitCilStmt@\verb`visitCilStmt`}
\begin{ocamldocdescription}
Visit a statement


\end{ocamldocdescription}




\label{val:Cil.visitCilBlock}\begin{ocamldoccode}
val visitCilBlock : cilVisitor -> block -> block
\end{ocamldoccode}
\index{visitCilBlock@\verb`visitCilBlock`}
\begin{ocamldocdescription}
Visit a block


\end{ocamldocdescription}




\label{val:Cil.visitCilType}\begin{ocamldoccode}
val visitCilType : cilVisitor -> typ -> typ
\end{ocamldoccode}
\index{visitCilType@\verb`visitCilType`}
\begin{ocamldocdescription}
Visit a type


\end{ocamldocdescription}




\label{val:Cil.visitCilVarDecl}\begin{ocamldoccode}
val visitCilVarDecl : cilVisitor -> varinfo -> varinfo
\end{ocamldoccode}
\index{visitCilVarDecl@\verb`visitCilVarDecl`}
\begin{ocamldocdescription}
Visit a variable declaration


\end{ocamldocdescription}




\label{val:Cil.visitCilInit}\begin{ocamldoccode}
val visitCilInit : cilVisitor -> varinfo -> offset -> init -> init
\end{ocamldoccode}
\index{visitCilInit@\verb`visitCilInit`}
\begin{ocamldocdescription}
Visit an initializer, pass also the global to which this belongs and the 
 offset.


\end{ocamldocdescription}




\label{val:Cil.visitCilAttributes}\begin{ocamldoccode}
val visitCilAttributes : cilVisitor -> attribute list -> attribute list
\end{ocamldoccode}
\index{visitCilAttributes@\verb`visitCilAttributes`}
\begin{ocamldocdescription}
Visit a list of attributes


\end{ocamldocdescription}




{\bf Utility functions}



\label{val:Cil.msvcMode}\begin{ocamldoccode}
val msvcMode : bool ref
\end{ocamldoccode}
\index{msvcMode@\verb`msvcMode`}
\begin{ocamldocdescription}
Whether the pretty printer should print output for the MS VC compiler.
   Default is GCC. After you set this function you should call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}].


\end{ocamldocdescription}




\label{val:Cil.useLogicalOperators}\begin{ocamldoccode}
val useLogicalOperators : bool ref
\end{ocamldoccode}
\index{useLogicalOperators@\verb`useLogicalOperators`}
\begin{ocamldocdescription}
Whether to use the logical operands LAnd and LOr. By default, do not use 
 them because they are unlike other expressions and do not evaluate both of 
 their operands


\end{ocamldocdescription}




\label{val:Cil.oldstyleExternInline}\begin{ocamldoccode}
val oldstyleExternInline : bool ref
\end{ocamldoccode}
\index{oldstyleExternInline@\verb`oldstyleExternInline`}
\begin{ocamldocdescription}
Set this to true to get old-style handling of gcc's extern inline C extension:
   old-style: the extern inline definition is used until the actual definition is
     seen (as long as optimization is enabled)
   new-style: the extern inline definition is used only if there is no actual
     definition (as long as optimization is enabled)
   Note that CIL assumes that optimization is always enabled ;-)


\end{ocamldocdescription}




\label{val:Cil.constFoldVisitor}\begin{ocamldoccode}
val constFoldVisitor : bool -> cilVisitor
\end{ocamldoccode}
\index{constFoldVisitor@\verb`constFoldVisitor`}
\begin{ocamldocdescription}
A visitor that does constant folding. Pass as argument whether you want 
 machine specific simplifications to be done, or not.


\end{ocamldocdescription}




\label{type:Cil.lineDirectiveStyle}\begin{ocamldoccode}
type lineDirectiveStyle =
  | LineComment
\end{ocamldoccode}
\begin{ocamldoccomment}
Before every element, print the line 
 number in comments. This is ignored by 
 processing tools (thus errors are reproted 
 in the CIL output), but useful for 
 visual inspection
\end{ocamldoccomment}
\begin{ocamldoccode}
  | LineCommentSparse
\end{ocamldoccode}
\begin{ocamldoccomment}
Like LineComment but only print a line 
 directive for a new source line
\end{ocamldoccomment}
\begin{ocamldoccode}
  | LinePreprocessorInput
\end{ocamldoccode}
\begin{ocamldoccomment}
Use \verb`#` nnn directives (in gcc mode)
\end{ocamldoccomment}
\begin{ocamldoccode}
  | LinePreprocessorOutput
\end{ocamldoccode}
\begin{ocamldoccomment}
Use \verb`#`line directives
\end{ocamldoccomment}
\index{lineDirectiveStyle@\verb`lineDirectiveStyle`}
\begin{ocamldocdescription}
Styles of printing line directives


\end{ocamldocdescription}




\label{val:Cil.lineDirectiveStyle}\begin{ocamldoccode}
val lineDirectiveStyle : lineDirectiveStyle option ref
\end{ocamldoccode}
\index{lineDirectiveStyle@\verb`lineDirectiveStyle`}
\begin{ocamldocdescription}
How to print line directives


\end{ocamldocdescription}




\label{val:Cil.print-underscoreCIL-underscoreInput}\begin{ocamldoccode}
val print_CIL_Input : bool ref
\end{ocamldoccode}
\index{print-underscoreCIL-underscoreInput@\verb`print_CIL_Input`}
\begin{ocamldocdescription}
Whether we print something that will only be used as input to our own 
 parser. In that case we are a bit more liberal in what we print


\end{ocamldocdescription}




\label{val:Cil.printCilAsIs}\begin{ocamldoccode}
val printCilAsIs : bool ref
\end{ocamldoccode}
\index{printCilAsIs@\verb`printCilAsIs`}
\begin{ocamldocdescription}
Whether to print the CIL as they are, without trying to be smart and 
 print nicer code. Normally this is false, in which case the pretty 
 printer will turn the while(1) loops of CIL into nicer loops, will not 
 print empty "else" blocks, etc. There is one case howewer in which if you 
 turn this on you will get code that does not compile: if you use varargs 
 the \_\_builtin\_va\_arg function will be printed in its internal form.


\end{ocamldocdescription}




\label{val:Cil.lineLength}\begin{ocamldoccode}
val lineLength : int ref
\end{ocamldoccode}
\index{lineLength@\verb`lineLength`}
\begin{ocamldocdescription}
The length used when wrapping output lines.  Setting this variable to
 a large integer will prevent wrapping and make \verb`#`line directives more
 accurate.


\end{ocamldocdescription}




\label{val:Cil.forgcc}\begin{ocamldoccode}
val forgcc : string -> string
\end{ocamldoccode}
\index{forgcc@\verb`forgcc`}
\begin{ocamldocdescription}
Return the string 's' if we're printing output for gcc, suppres
  it if we're printing for CIL to parse back in.  the purpose is to
  hide things from gcc that it complains about, but still be able
  to do lossless transformations when CIL is the consumer


\end{ocamldocdescription}




{\bf Debugging support}



\label{val:Cil.currentLoc}\begin{ocamldoccode}
val currentLoc : location ref
\end{ocamldoccode}
\index{currentLoc@\verb`currentLoc`}
\begin{ocamldocdescription}
A reference to the current location. If you are careful to set this to 
 the current location then you can use some built-in logging functions that 
 will print the location.


\end{ocamldocdescription}




\label{val:Cil.currentGlobal}\begin{ocamldoccode}
val currentGlobal : global ref
\end{ocamldoccode}
\index{currentGlobal@\verb`currentGlobal`}
\begin{ocamldocdescription}
A reference to the current global being visited


\end{ocamldocdescription}




CIL has a fairly easy to use mechanism for printing error messages. This 
 mechanism is built on top of the pretty-printer mechanism (see 
 {\tt{Pretty.doc}}[\ref{type:Pretty.doc}]) and the error-message modules (see {\tt{Errormsg.error}}[\ref{val:Errormsg.error}]). 


 Here is a typical example for printing a log message: \begin{verbatim}
ignore (Errormsg.log "Expression %a is not positive (at %s:%i)\n"
                        d_exp e loc.file loc.line)
\end{verbatim}


 and here is an example of how you print a fatal error message that stop the 
 execution: \begin{verbatim}
Errormsg.s (Errormsg.bug "Why am I here?")
\end{verbatim}


 Notice that you can use C format strings with some extension. The most 
useful extension is "\%a" that means to consumer the next two argument from 
the argument list and to apply the first to {\tt{unit}} and then to the second 
and to print the resulting {\tt{Pretty.doc}}[\ref{type:Pretty.doc}]. For each major type in CIL there is 
a corresponding function that pretty-prints an element of that type:



\label{val:Cil.d-underscoreloc}\begin{ocamldoccode}
val d_loc : unit -> location -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreloc@\verb`d_loc`}
\begin{ocamldocdescription}
Pretty-print a location


\end{ocamldocdescription}




\label{val:Cil.d-underscorethisloc}\begin{ocamldoccode}
val d_thisloc : unit -> Pretty.doc
\end{ocamldoccode}
\index{d-underscorethisloc@\verb`d_thisloc`}
\begin{ocamldocdescription}
Pretty-print the {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}]


\end{ocamldocdescription}




\label{val:Cil.d-underscoreikind}\begin{ocamldoccode}
val d_ikind : unit -> ikind -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreikind@\verb`d_ikind`}
\begin{ocamldocdescription}
Pretty-print an integer of a given kind


\end{ocamldocdescription}




\label{val:Cil.d-underscorefkind}\begin{ocamldoccode}
val d_fkind : unit -> fkind -> Pretty.doc
\end{ocamldoccode}
\index{d-underscorefkind@\verb`d_fkind`}
\begin{ocamldocdescription}
Pretty-print a floating-point kind


\end{ocamldocdescription}




\label{val:Cil.d-underscorestorage}\begin{ocamldoccode}
val d_storage : unit -> storage -> Pretty.doc
\end{ocamldoccode}
\index{d-underscorestorage@\verb`d_storage`}
\begin{ocamldocdescription}
Pretty-print storage-class information


\end{ocamldocdescription}




\label{val:Cil.d-underscoreconst}\begin{ocamldoccode}
val d_const : unit -> constant -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreconst@\verb`d_const`}
\begin{ocamldocdescription}
Pretty-print a constant


\end{ocamldocdescription}




\label{val:Cil.derefStarLevel}\begin{ocamldoccode}
val derefStarLevel : int
\end{ocamldoccode}
\index{derefStarLevel@\verb`derefStarLevel`}




\label{val:Cil.indexLevel}\begin{ocamldoccode}
val indexLevel : int
\end{ocamldoccode}
\index{indexLevel@\verb`indexLevel`}




\label{val:Cil.arrowLevel}\begin{ocamldoccode}
val arrowLevel : int
\end{ocamldoccode}
\index{arrowLevel@\verb`arrowLevel`}




\label{val:Cil.addrOfLevel}\begin{ocamldoccode}
val addrOfLevel : int
\end{ocamldoccode}
\index{addrOfLevel@\verb`addrOfLevel`}




\label{val:Cil.additiveLevel}\begin{ocamldoccode}
val additiveLevel : int
\end{ocamldoccode}
\index{additiveLevel@\verb`additiveLevel`}




\label{val:Cil.comparativeLevel}\begin{ocamldoccode}
val comparativeLevel : int
\end{ocamldoccode}
\index{comparativeLevel@\verb`comparativeLevel`}




\label{val:Cil.bitwiseLevel}\begin{ocamldoccode}
val bitwiseLevel : int
\end{ocamldoccode}
\index{bitwiseLevel@\verb`bitwiseLevel`}




\label{val:Cil.getParenthLevel}\begin{ocamldoccode}
val getParenthLevel : exp -> int
\end{ocamldoccode}
\index{getParenthLevel@\verb`getParenthLevel`}
\begin{ocamldocdescription}
Parentheses level. An expression "a op b" is printed parenthesized if its 
 parentheses level is $\geq$ that that of its context. Identifiers have the 
 lowest level and weakly binding operators (e.g. \textbar ) have the largest level. 
 The correctness criterion is that a smaller level MUST correspond to a 
 stronger precedence!


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{class type cilPrinter = }}\end{ocamldoccode}
\label{classtype:Cil.cilPrinter}\index{cilPrinter@\verb`cilPrinter`}

\begin{ocamldocobjectend}


\label{method:Cil.cilPrinter.setCurrentFormals}\begin{ocamldoccode}
method setCurrentFormals : Cil.varinfo list -> unit
\end{ocamldoccode}
\index{setCurrentFormals@\verb`setCurrentFormals`}


\label{method:Cil.cilPrinter.setPrintInstrTerminator}\begin{ocamldoccode}
method setPrintInstrTerminator : string -> unit
\end{ocamldoccode}
\index{setPrintInstrTerminator@\verb`setPrintInstrTerminator`}


\label{method:Cil.cilPrinter.getPrintInstrTerminator}\begin{ocamldoccode}
method getPrintInstrTerminator : unit -> string
\end{ocamldoccode}
\index{getPrintInstrTerminator@\verb`getPrintInstrTerminator`}


\label{method:Cil.cilPrinter.pVDecl}\begin{ocamldoccode}
method pVDecl : unit -> Cil.varinfo -> Pretty.doc
\end{ocamldoccode}
\index{pVDecl@\verb`pVDecl`}
\begin{ocamldocdescription}
Invoked for each variable declaration. Note that variable 
 declarations are all the {\tt{GVar}}, {\tt{GVarDecl}}, {\tt{GFun}}, all the {\tt{varinfo}} 
 in formals of function types, and the formals and locals for function 
 definitions.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pVar}\begin{ocamldoccode}
method pVar : Cil.varinfo -> Pretty.doc
\end{ocamldoccode}
\index{pVar@\verb`pVar`}
\begin{ocamldocdescription}
Invoked on each variable use.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pLval}\begin{ocamldoccode}
method pLval : unit -> Cil.lval -> Pretty.doc
\end{ocamldoccode}
\index{pLval@\verb`pLval`}
\begin{ocamldocdescription}
Invoked on each lvalue occurrence


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pOffset}\begin{ocamldoccode}
method pOffset : Pretty.doc -> Cil.offset -> Pretty.doc
\end{ocamldoccode}
\index{pOffset@\verb`pOffset`}
\begin{ocamldocdescription}
Invoked on each offset occurrence. The second argument is the base.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pInstr}\begin{ocamldoccode}
method pInstr : unit -> Cil.instr -> Pretty.doc
\end{ocamldoccode}
\index{pInstr@\verb`pInstr`}
\begin{ocamldocdescription}
Invoked on each instruction occurrence.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pLabel}\begin{ocamldoccode}
method pLabel : unit -> Cil.label -> Pretty.doc
\end{ocamldoccode}
\index{pLabel@\verb`pLabel`}
\begin{ocamldocdescription}
Print a label.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pStmt}\begin{ocamldoccode}
method pStmt : unit -> Cil.stmt -> Pretty.doc
\end{ocamldoccode}
\index{pStmt@\verb`pStmt`}
\begin{ocamldocdescription}
Control-flow statement. This is used by 
 {\tt{Cil.printGlobal}}[\ref{val:Cil.printGlobal}] and by {\tt{Cil.dumpGlobal}}[\ref{val:Cil.dumpGlobal}].


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.dStmt}\begin{ocamldoccode}
method dStmt : out_channel -> int -> Cil.stmt -> unit
\end{ocamldoccode}
\index{dStmt@\verb`dStmt`}
\begin{ocamldocdescription}
Dump a control-flow statement to a file with a given indentation. 
 This is used by {\tt{Cil.dumpGlobal}}[\ref{val:Cil.dumpGlobal}].


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.dBlock}\begin{ocamldoccode}
method dBlock : out_channel -> int -> Cil.block -> unit
\end{ocamldoccode}
\index{dBlock@\verb`dBlock`}
\begin{ocamldocdescription}
Dump a control-flow block to a file with a given indentation. 
 This is used by {\tt{Cil.dumpGlobal}}[\ref{val:Cil.dumpGlobal}].


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pBlock}\begin{ocamldoccode}
method pBlock : unit -> Cil.block -> Pretty.doc
\end{ocamldoccode}
\index{pBlock@\verb`pBlock`}
\begin{ocamldocdescription}
Print a block.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pGlobal}\begin{ocamldoccode}
method pGlobal : unit -> Cil.global -> Pretty.doc
\end{ocamldoccode}
\index{pGlobal@\verb`pGlobal`}
\begin{ocamldocdescription}
Global (vars, types, etc.). This can be slow and is used only by 
 {\tt{Cil.printGlobal}}[\ref{val:Cil.printGlobal}] but not by {\tt{Cil.dumpGlobal}}[\ref{val:Cil.dumpGlobal}].


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.dGlobal}\begin{ocamldoccode}
method dGlobal : out_channel -> Cil.global -> unit
\end{ocamldoccode}
\index{dGlobal@\verb`dGlobal`}
\begin{ocamldocdescription}
Dump a global to a file with a given indentation. This is used by 
 {\tt{Cil.dumpGlobal}}[\ref{val:Cil.dumpGlobal}]


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pFieldDecl}\begin{ocamldoccode}
method pFieldDecl : unit -> Cil.fieldinfo -> Pretty.doc
\end{ocamldoccode}
\index{pFieldDecl@\verb`pFieldDecl`}
\begin{ocamldocdescription}
A field declaration


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pType}\begin{ocamldoccode}
method pType : Pretty.doc option -> unit -> Cil.typ -> Pretty.doc
\end{ocamldoccode}
\index{pType@\verb`pType`}
\begin{ocamldocdescription}
Use of some type in some declaration. The first argument is used to print 
 the declared element, or is None if we are just printing a type with no 
 name being declared. Note that for structure/union and enumeration types 
 the definition of the composite type is not visited. Use {\tt{vglob}} to 
 visit it.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pAttr}\begin{ocamldoccode}
method pAttr : Cil.attribute -> Pretty.doc * bool
\end{ocamldoccode}
\index{pAttr@\verb`pAttr`}
\begin{ocamldocdescription}
Attribute. Also return an indication whether this attribute must be 
 printed inside the \_\_attribute\_\_ list or not.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pAttrParam}\begin{ocamldoccode}
method pAttrParam : unit -> Cil.attrparam -> Pretty.doc
\end{ocamldoccode}
\index{pAttrParam@\verb`pAttrParam`}
\begin{ocamldocdescription}
Attribute parameter


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pAttrs}\begin{ocamldoccode}
method pAttrs : unit -> Cil.attributes -> Pretty.doc
\end{ocamldoccode}
\index{pAttrs@\verb`pAttrs`}
\begin{ocamldocdescription}
Attribute lists


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pLineDirective}\begin{ocamldoccode}
method pLineDirective : ?forcefile:bool -> Cil.location -> Pretty.doc
\end{ocamldoccode}
\index{pLineDirective@\verb`pLineDirective`}
\begin{ocamldocdescription}
Print a line-number. This is assumed to come always on an empty line. 
 If the forcefile argument is present and is true then the file name 
 will be printed always. Otherwise the file name is printed only if it 
 is different from the last time time this function is called. The last 
 file name is stored in a private field inside the cilPrinter object.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pStmtKind}\begin{ocamldoccode}
method pStmtKind : Cil.stmt -> unit -> Cil.stmtkind -> Pretty.doc
\end{ocamldoccode}
\index{pStmtKind@\verb`pStmtKind`}
\begin{ocamldocdescription}
Print a statement kind. The code to be printed is given in the
 {\tt{Cil.stmtkind}}[\ref{type:Cil.stmtkind}] argument.  The initial {\tt{Cil.stmt}}[\ref{type:Cil.stmt}] argument
 records the statement which follows the one being printed;
 {\tt{Cil.defaultCilPrinterClass}}[\ref{class:Cil.defaultCilPrinterClass}] uses this information to prettify
 statement printing in certain special cases.


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pExp}\begin{ocamldoccode}
method pExp : unit -> Cil.exp -> Pretty.doc
\end{ocamldoccode}
\index{pExp@\verb`pExp`}
\begin{ocamldocdescription}
Print expressions


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.pInit}\begin{ocamldoccode}
method pInit : unit -> Cil.init -> Pretty.doc
\end{ocamldoccode}
\index{pInit@\verb`pInit`}
\begin{ocamldocdescription}
Print initializers. This can be slow and is used by 
 {\tt{Cil.printGlobal}}[\ref{val:Cil.printGlobal}] but not by {\tt{Cil.dumpGlobal}}[\ref{val:Cil.dumpGlobal}].


\end{ocamldocdescription}


\label{method:Cil.cilPrinter.dInit}\begin{ocamldoccode}
method dInit : out_channel -> int -> Cil.init -> unit
\end{ocamldoccode}
\index{dInit@\verb`dInit`}
\begin{ocamldocdescription}
Dump a global to a file with a given indentation. This is used by 
 {\tt{Cil.dumpGlobal}}[\ref{val:Cil.dumpGlobal}]


\end{ocamldocdescription}
\end{ocamldocobjectend}


\begin{ocamldocdescription}
A printer interface for CIL trees. Create instantiations of 
 this type by specializing the class {\tt{Cil.defaultCilPrinterClass}}[\ref{class:Cil.defaultCilPrinterClass}].


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{class defaultCilPrinterClass : }}{\tt{cilPrinter}}\end{ocamldoccode}
\label{class:Cil.defaultCilPrinterClass}\index{defaultCilPrinterClass@\verb`defaultCilPrinterClass`}







\label{val:Cil.defaultCilPrinter}\begin{ocamldoccode}
val defaultCilPrinter : cilPrinter
\end{ocamldoccode}
\index{defaultCilPrinter@\verb`defaultCilPrinter`}




\begin{ocamldoccode}
{\tt{class plainCilPrinterClass : }}{\tt{cilPrinter}}\end{ocamldoccode}
\label{class:Cil.plainCilPrinterClass}\index{plainCilPrinterClass@\verb`plainCilPrinterClass`}



\begin{ocamldocdescription}
These are pretty-printers that will show you more details on the internal 
 CIL representation, without trying hard to make it look like C


\end{ocamldocdescription}




\label{val:Cil.plainCilPrinter}\begin{ocamldoccode}
val plainCilPrinter : cilPrinter
\end{ocamldoccode}
\index{plainCilPrinter@\verb`plainCilPrinter`}




\begin{ocamldoccode}
{\tt{class type descriptiveCilPrinter = }}\end{ocamldoccode}
\label{classtype:Cil.descriptiveCilPrinter}\index{descriptiveCilPrinter@\verb`descriptiveCilPrinter`}

\begin{ocamldocobjectend}


{\tt{inherit Cil.cilPrinter}} [\ref{classtype:Cil.cilPrinter}]

\label{method:Cil.descriptiveCilPrinter.startTemps}\begin{ocamldoccode}
method startTemps : unit -> unit
\end{ocamldoccode}
\index{startTemps@\verb`startTemps`}


\label{method:Cil.descriptiveCilPrinter.stopTemps}\begin{ocamldoccode}
method stopTemps : unit -> unit
\end{ocamldoccode}
\index{stopTemps@\verb`stopTemps`}


\label{method:Cil.descriptiveCilPrinter.pTemps}\begin{ocamldoccode}
method pTemps : unit -> Pretty.doc
\end{ocamldoccode}
\index{pTemps@\verb`pTemps`}
\end{ocamldocobjectend}






\begin{ocamldoccode}
{\tt{class descriptiveCilPrinterClass : }}{\tt{bool -> }}{\tt{descriptiveCilPrinter}}\end{ocamldoccode}
\label{class:Cil.descriptiveCilPrinterClass}\index{descriptiveCilPrinterClass@\verb`descriptiveCilPrinterClass`}



\begin{ocamldocdescription}
Like defaultCilPrinterClass, but instead of temporary variable
      names it prints the description that was provided when the temp was
      created.  This is usually better for messages that are printed for end
      users, although you may want the temporary names for debugging.


      The boolean here enables descriptive printing.  Usually use true
      here, but you can set enable to false to make this class behave
      like defaultCilPrinterClass. This allows subclasses to turn the
      feature off.


\end{ocamldocdescription}




\label{val:Cil.descriptiveCilPrinter}\begin{ocamldoccode}
val descriptiveCilPrinter : descriptiveCilPrinter
\end{ocamldoccode}
\index{descriptiveCilPrinter@\verb`descriptiveCilPrinter`}




\label{val:Cil.printerForMaincil}\begin{ocamldoccode}
val printerForMaincil : cilPrinter ref
\end{ocamldoccode}
\index{printerForMaincil@\verb`printerForMaincil`}
\begin{ocamldocdescription}
zra: This is the pretty printer that Maincil will use.
   by default it is set to defaultCilPrinter


\end{ocamldocdescription}




\label{val:Cil.printType}\begin{ocamldoccode}
val printType : cilPrinter -> unit -> typ -> Pretty.doc
\end{ocamldoccode}
\index{printType@\verb`printType`}
\begin{ocamldocdescription}
Print a type given a pretty printer


\end{ocamldocdescription}




\label{val:Cil.printExp}\begin{ocamldoccode}
val printExp : cilPrinter -> unit -> exp -> Pretty.doc
\end{ocamldoccode}
\index{printExp@\verb`printExp`}
\begin{ocamldocdescription}
Print an expression given a pretty printer


\end{ocamldocdescription}




\label{val:Cil.printLval}\begin{ocamldoccode}
val printLval : cilPrinter -> unit -> lval -> Pretty.doc
\end{ocamldoccode}
\index{printLval@\verb`printLval`}
\begin{ocamldocdescription}
Print an lvalue given a pretty printer


\end{ocamldocdescription}




\label{val:Cil.printGlobal}\begin{ocamldoccode}
val printGlobal : cilPrinter -> unit -> global -> Pretty.doc
\end{ocamldoccode}
\index{printGlobal@\verb`printGlobal`}
\begin{ocamldocdescription}
Print a global given a pretty printer


\end{ocamldocdescription}




\label{val:Cil.printAttr}\begin{ocamldoccode}
val printAttr : cilPrinter -> unit -> attribute -> Pretty.doc
\end{ocamldoccode}
\index{printAttr@\verb`printAttr`}
\begin{ocamldocdescription}
Print an attribute given a pretty printer


\end{ocamldocdescription}




\label{val:Cil.printAttrs}\begin{ocamldoccode}
val printAttrs : cilPrinter -> unit -> attributes -> Pretty.doc
\end{ocamldoccode}
\index{printAttrs@\verb`printAttrs`}
\begin{ocamldocdescription}
Print a set of attributes given a pretty printer


\end{ocamldocdescription}




\label{val:Cil.printInstr}\begin{ocamldoccode}
val printInstr : cilPrinter -> unit -> instr -> Pretty.doc
\end{ocamldoccode}
\index{printInstr@\verb`printInstr`}
\begin{ocamldocdescription}
Print an instruction given a pretty printer


\end{ocamldocdescription}




\label{val:Cil.printStmt}\begin{ocamldoccode}
val printStmt : cilPrinter -> unit -> stmt -> Pretty.doc
\end{ocamldoccode}
\index{printStmt@\verb`printStmt`}
\begin{ocamldocdescription}
Print a statement given a pretty printer. This can take very long 
 (or even overflow the stack) for huge statements. Use {\tt{Cil.dumpStmt}}[\ref{val:Cil.dumpStmt}] 
 instead.


\end{ocamldocdescription}




\label{val:Cil.printBlock}\begin{ocamldoccode}
val printBlock : cilPrinter -> unit -> block -> Pretty.doc
\end{ocamldoccode}
\index{printBlock@\verb`printBlock`}
\begin{ocamldocdescription}
Print a block given a pretty printer. This can take very long 
 (or even overflow the stack) for huge block. Use {\tt{Cil.dumpBlock}}[\ref{val:Cil.dumpBlock}] 
 instead.


\end{ocamldocdescription}




\label{val:Cil.dumpStmt}\begin{ocamldoccode}
val dumpStmt : cilPrinter -> out_channel -> int -> stmt -> unit
\end{ocamldoccode}
\index{dumpStmt@\verb`dumpStmt`}
\begin{ocamldocdescription}
Dump a statement to a file using a given indentation. Use this instead of 
 {\tt{Cil.printStmt}}[\ref{val:Cil.printStmt}] whenever possible.


\end{ocamldocdescription}




\label{val:Cil.dumpBlock}\begin{ocamldoccode}
val dumpBlock : cilPrinter -> out_channel -> int -> block -> unit
\end{ocamldoccode}
\index{dumpBlock@\verb`dumpBlock`}
\begin{ocamldocdescription}
Dump a block to a file using a given indentation. Use this instead of 
 {\tt{Cil.printBlock}}[\ref{val:Cil.printBlock}] whenever possible.


\end{ocamldocdescription}




\label{val:Cil.printInit}\begin{ocamldoccode}
val printInit : cilPrinter -> unit -> init -> Pretty.doc
\end{ocamldoccode}
\index{printInit@\verb`printInit`}
\begin{ocamldocdescription}
Print an initializer given a pretty printer. This can take very long 
 (or even overflow the stack) for huge initializers. Use {\tt{Cil.dumpInit}}[\ref{val:Cil.dumpInit}] 
 instead.


\end{ocamldocdescription}




\label{val:Cil.dumpInit}\begin{ocamldoccode}
val dumpInit : cilPrinter -> out_channel -> int -> init -> unit
\end{ocamldoccode}
\index{dumpInit@\verb`dumpInit`}
\begin{ocamldocdescription}
Dump an initializer to a file using a given indentation. Use this instead of 
 {\tt{Cil.printInit}}[\ref{val:Cil.printInit}] whenever possible.


\end{ocamldocdescription}




\label{val:Cil.d-underscoretype}\begin{ocamldoccode}
val d_type : unit -> typ -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoretype@\verb`d_type`}
\begin{ocamldocdescription}
Pretty-print a type using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]


\end{ocamldocdescription}




\label{val:Cil.d-underscoreexp}\begin{ocamldoccode}
val d_exp : unit -> exp -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreexp@\verb`d_exp`}
\begin{ocamldocdescription}
Pretty-print an expression using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]


\end{ocamldocdescription}




\label{val:Cil.d-underscorelval}\begin{ocamldoccode}
val d_lval : unit -> lval -> Pretty.doc
\end{ocamldoccode}
\index{d-underscorelval@\verb`d_lval`}
\begin{ocamldocdescription}
Pretty-print an lvalue using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]


\end{ocamldocdescription}




\label{val:Cil.d-underscoreoffset}\begin{ocamldoccode}
val d_offset : Pretty.doc -> unit -> offset -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreoffset@\verb`d_offset`}
\begin{ocamldocdescription}
Pretty-print an offset using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}], given the pretty 
 printing for the base.


\end{ocamldocdescription}




\label{val:Cil.d-underscoreinit}\begin{ocamldoccode}
val d_init : unit -> init -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreinit@\verb`d_init`}
\begin{ocamldocdescription}
Pretty-print an initializer using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}].  This can be 
 extremely slow (or even overflow the stack) for huge initializers. Use 
 {\tt{Cil.dumpInit}}[\ref{val:Cil.dumpInit}] instead.


\end{ocamldocdescription}




\label{val:Cil.d-underscorebinop}\begin{ocamldoccode}
val d_binop : unit -> binop -> Pretty.doc
\end{ocamldoccode}
\index{d-underscorebinop@\verb`d_binop`}
\begin{ocamldocdescription}
Pretty-print a binary operator


\end{ocamldocdescription}




\label{val:Cil.d-underscoreunop}\begin{ocamldoccode}
val d_unop : unit -> unop -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreunop@\verb`d_unop`}
\begin{ocamldocdescription}
Pretty-print a unary operator


\end{ocamldocdescription}




\label{val:Cil.d-underscoreattr}\begin{ocamldoccode}
val d_attr : unit -> attribute -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreattr@\verb`d_attr`}
\begin{ocamldocdescription}
Pretty-print an attribute using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]


\end{ocamldocdescription}




\label{val:Cil.d-underscoreattrparam}\begin{ocamldoccode}
val d_attrparam : unit -> attrparam -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreattrparam@\verb`d_attrparam`}
\begin{ocamldocdescription}
Pretty-print an argument of an attribute using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]


\end{ocamldocdescription}




\label{val:Cil.d-underscoreattrlist}\begin{ocamldoccode}
val d_attrlist : unit -> attributes -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreattrlist@\verb`d_attrlist`}
\begin{ocamldocdescription}
Pretty-print a list of attributes using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]


\end{ocamldocdescription}




\label{val:Cil.d-underscoreinstr}\begin{ocamldoccode}
val d_instr : unit -> instr -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreinstr@\verb`d_instr`}
\begin{ocamldocdescription}
Pretty-print an instruction using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]


\end{ocamldocdescription}




\label{val:Cil.d-underscorelabel}\begin{ocamldoccode}
val d_label : unit -> label -> Pretty.doc
\end{ocamldoccode}
\index{d-underscorelabel@\verb`d_label`}
\begin{ocamldocdescription}
Pretty-print a label using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]


\end{ocamldocdescription}




\label{val:Cil.d-underscorestmt}\begin{ocamldoccode}
val d_stmt : unit -> stmt -> Pretty.doc
\end{ocamldoccode}
\index{d-underscorestmt@\verb`d_stmt`}
\begin{ocamldocdescription}
Pretty-print a statement using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]. This can be 
 extremely slow (or even overflow the stack) for huge statements. Use 
 {\tt{Cil.dumpStmt}}[\ref{val:Cil.dumpStmt}] instead.


\end{ocamldocdescription}




\label{val:Cil.d-underscoreblock}\begin{ocamldoccode}
val d_block : unit -> block -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreblock@\verb`d_block`}
\begin{ocamldocdescription}
Pretty-print a block using {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]. This can be 
 extremely slow (or even overflow the stack) for huge blocks. Use 
 {\tt{Cil.dumpBlock}}[\ref{val:Cil.dumpBlock}] instead.


\end{ocamldocdescription}




\label{val:Cil.d-underscoreglobal}\begin{ocamldoccode}
val d_global : unit -> global -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreglobal@\verb`d_global`}
\begin{ocamldocdescription}
Pretty-print the internal representation of a global using 
 {\tt{Cil.defaultCilPrinter}}[\ref{val:Cil.defaultCilPrinter}]. This can be extremely slow (or even overflow the 
 stack) for huge globals (such as arrays with lots of initializers). Use 
 {\tt{Cil.dumpGlobal}}[\ref{val:Cil.dumpGlobal}] instead.


\end{ocamldocdescription}




\label{val:Cil.dn-underscoreexp}\begin{ocamldoccode}
val dn_exp : unit -> exp -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscoreexp@\verb`dn_exp`}
\begin{ocamldocdescription}
Versions of the above pretty printers, that don't print \verb`#`line directives


\end{ocamldocdescription}




\label{val:Cil.dn-underscorelval}\begin{ocamldoccode}
val dn_lval : unit -> lval -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscorelval@\verb`dn_lval`}




\label{val:Cil.dn-underscoreinit}\begin{ocamldoccode}
val dn_init : unit -> init -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscoreinit@\verb`dn_init`}




\label{val:Cil.dn-underscoretype}\begin{ocamldoccode}
val dn_type : unit -> typ -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscoretype@\verb`dn_type`}




\label{val:Cil.dn-underscoreglobal}\begin{ocamldoccode}
val dn_global : unit -> global -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscoreglobal@\verb`dn_global`}




\label{val:Cil.dn-underscoreattrlist}\begin{ocamldoccode}
val dn_attrlist : unit -> attributes -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscoreattrlist@\verb`dn_attrlist`}




\label{val:Cil.dn-underscoreattr}\begin{ocamldoccode}
val dn_attr : unit -> attribute -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscoreattr@\verb`dn_attr`}




\label{val:Cil.dn-underscoreattrparam}\begin{ocamldoccode}
val dn_attrparam : unit -> attrparam -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscoreattrparam@\verb`dn_attrparam`}




\label{val:Cil.dn-underscorestmt}\begin{ocamldoccode}
val dn_stmt : unit -> stmt -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscorestmt@\verb`dn_stmt`}




\label{val:Cil.dn-underscoreinstr}\begin{ocamldoccode}
val dn_instr : unit -> instr -> Pretty.doc
\end{ocamldoccode}
\index{dn-underscoreinstr@\verb`dn_instr`}




\label{val:Cil.d-underscoreshortglobal}\begin{ocamldoccode}
val d_shortglobal : unit -> global -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreshortglobal@\verb`d_shortglobal`}
\begin{ocamldocdescription}
Pretty-print a short description of the global. This is useful for error 
 messages


\end{ocamldocdescription}




\label{val:Cil.dumpGlobal}\begin{ocamldoccode}
val dumpGlobal : cilPrinter -> out_channel -> global -> unit
\end{ocamldoccode}
\index{dumpGlobal@\verb`dumpGlobal`}
\begin{ocamldocdescription}
Pretty-print a global. Here you give the channel where the printout
 should be sent.


\end{ocamldocdescription}




\label{val:Cil.dumpFile}\begin{ocamldoccode}
val dumpFile : cilPrinter -> out_channel -> string -> file -> unit
\end{ocamldoccode}
\index{dumpFile@\verb`dumpFile`}
\begin{ocamldocdescription}
Pretty-print an entire file. Here you give the channel where the printout
 should be sent.


\end{ocamldocdescription}




the following error message producing functions also print a location in 
 the code. use {\tt{Errormsg.bug}}[\ref{val:Errormsg.bug}] and {\tt{Errormsg.unimp}}[\ref{val:Errormsg.unimp}] if you do not want 
 that



\label{val:Cil.bug}\begin{ocamldoccode}
val bug : ('a, unit, Pretty.doc) format -> 'a
\end{ocamldoccode}
\index{bug@\verb`bug`}
\begin{ocamldocdescription}
Like {\tt{Errormsg.bug}}[\ref{val:Errormsg.bug}] except that {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] is also printed


\end{ocamldocdescription}




\label{val:Cil.unimp}\begin{ocamldoccode}
val unimp : ('a, unit, Pretty.doc) format -> 'a
\end{ocamldoccode}
\index{unimp@\verb`unimp`}
\begin{ocamldocdescription}
Like {\tt{Errormsg.unimp}}[\ref{val:Errormsg.unimp}] except that {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}]is also printed


\end{ocamldocdescription}




\label{val:Cil.error}\begin{ocamldoccode}
val error : ('a, unit, Pretty.doc) format -> 'a
\end{ocamldoccode}
\index{error@\verb`error`}
\begin{ocamldocdescription}
Like {\tt{Errormsg.error}}[\ref{val:Errormsg.error}] except that {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] is also printed


\end{ocamldocdescription}




\label{val:Cil.errorLoc}\begin{ocamldoccode}
val errorLoc : location -> ('a, unit, Pretty.doc) format -> 'a
\end{ocamldoccode}
\index{errorLoc@\verb`errorLoc`}
\begin{ocamldocdescription}
Like {\tt{Cil.error}}[\ref{val:Cil.error}] except that it explicitly takes a location argument, 
 instead of using the {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}]


\end{ocamldocdescription}




\label{val:Cil.warn}\begin{ocamldoccode}
val warn : ('a, unit, Pretty.doc) format -> 'a
\end{ocamldoccode}
\index{warn@\verb`warn`}
\begin{ocamldocdescription}
Like {\tt{Errormsg.warn}}[\ref{val:Errormsg.warn}] except that {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] is also printed


\end{ocamldocdescription}




\label{val:Cil.warnOpt}\begin{ocamldoccode}
val warnOpt : ('a, unit, Pretty.doc) format -> 'a
\end{ocamldoccode}
\index{warnOpt@\verb`warnOpt`}
\begin{ocamldocdescription}
Like {\tt{Errormsg.warnOpt}}[\ref{val:Errormsg.warnOpt}] except that {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] is also printed. 
 This warning is printed only of {\tt{Errormsg.warnFlag}}[\ref{val:Errormsg.warnFlag}] is set.


\end{ocamldocdescription}




\label{val:Cil.warnContext}\begin{ocamldoccode}
val warnContext : ('a, unit, Pretty.doc) format -> 'a
\end{ocamldoccode}
\index{warnContext@\verb`warnContext`}
\begin{ocamldocdescription}
Like {\tt{Errormsg.warn}}[\ref{val:Errormsg.warn}] except that {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] and context 
    is also printed


\end{ocamldocdescription}




\label{val:Cil.warnContextOpt}\begin{ocamldoccode}
val warnContextOpt : ('a, unit, Pretty.doc) format -> 'a
\end{ocamldoccode}
\index{warnContextOpt@\verb`warnContextOpt`}
\begin{ocamldocdescription}
Like {\tt{Errormsg.warn}}[\ref{val:Errormsg.warn}] except that {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] and context is also 
 printed. This warning is printed only of {\tt{Errormsg.warnFlag}}[\ref{val:Errormsg.warnFlag}] is set.


\end{ocamldocdescription}




\label{val:Cil.warnLoc}\begin{ocamldoccode}
val warnLoc : location -> ('a, unit, Pretty.doc) format -> 'a
\end{ocamldoccode}
\index{warnLoc@\verb`warnLoc`}
\begin{ocamldocdescription}
Like {\tt{Cil.warn}}[\ref{val:Cil.warn}] except that it explicitly takes a location argument, 
 instead of using the {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}]


\end{ocamldocdescription}




Sometimes you do not want to see the syntactic sugar that the above 
 pretty-printing functions add. In that case you can use the following 
 pretty-printing functions. But note that the output of these functions is 
 not valid C



\label{val:Cil.d-underscoreplainexp}\begin{ocamldoccode}
val d_plainexp : unit -> exp -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreplainexp@\verb`d_plainexp`}
\begin{ocamldocdescription}
Pretty-print the internal representation of an expression


\end{ocamldocdescription}




\label{val:Cil.d-underscoreplaininit}\begin{ocamldoccode}
val d_plaininit : unit -> init -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreplaininit@\verb`d_plaininit`}
\begin{ocamldocdescription}
Pretty-print the internal representation of an integer


\end{ocamldocdescription}




\label{val:Cil.d-underscoreplainlval}\begin{ocamldoccode}
val d_plainlval : unit -> lval -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreplainlval@\verb`d_plainlval`}
\begin{ocamldocdescription}
Pretty-print the internal representation of an lvalue


\end{ocamldocdescription}




Pretty-print the internal representation of an lvalue offset 
val d\_plainoffset: unit $\rightarrow$ offset $\rightarrow$ Pretty.doc



\label{val:Cil.d-underscoreplaintype}\begin{ocamldoccode}
val d_plaintype : unit -> typ -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreplaintype@\verb`d_plaintype`}
\begin{ocamldocdescription}
Pretty-print the internal representation of a type


\end{ocamldocdescription}




\label{val:Cil.dd-underscoreexp}\begin{ocamldoccode}
val dd_exp : unit -> exp -> Pretty.doc
\end{ocamldoccode}
\index{dd-underscoreexp@\verb`dd_exp`}
\begin{ocamldocdescription}
Pretty-print an expression while printing descriptions rather than names
  of temporaries.

Pretty-print an lvalue on the left side of an assignment.
    If there is an offset or memory dereference, temporaries will
    be replaced by descriptions as in dd\_exp.  If the lval is a temp var,
    that var will not be replaced by a description; use "dd\_exp () (Lval lv)"
    if that's what you want.


\end{ocamldocdescription}




\label{val:Cil.dd-underscorelval}\begin{ocamldoccode}
val dd_lval : unit -> lval -> Pretty.doc
\end{ocamldoccode}
\index{dd-underscorelval@\verb`dd_lval`}




{\bf ALPHA conversion} has been moved to the Alpha module.



\label{val:Cil.uniqueVarNames}\begin{ocamldoccode}
val uniqueVarNames : file -> unit
\end{ocamldoccode}
\index{uniqueVarNames@\verb`uniqueVarNames`}
\begin{ocamldocdescription}
Assign unique names to local variables. This might be necessary after you 
 transformed the code and added or renamed some new variables. Names are 
 not used by CIL internally, but once you print the file out the compiler 
 downstream might be confused. You might 
 have added a new global that happens to have the same name as a local in 
 some function. Rename the local to ensure that there would never be 
 confusioin. Or, viceversa, you might have added a local with a name that 
 conflicts with a global


\end{ocamldocdescription}




{\bf Optimization Passes}



\label{val:Cil.peepHole2}\begin{ocamldoccode}
val peepHole2 : (instr * instr -> instr list option) -> stmt list -> unit
\end{ocamldoccode}
\index{peepHole2@\verb`peepHole2`}
\begin{ocamldocdescription}
A peephole optimizer that processes two adjacent instructions and possibly 
    replaces them both. If some replacement happens, then the new instructions
    are themselves subject to optimization


\end{ocamldocdescription}




\label{val:Cil.peepHole1}\begin{ocamldoccode}
val peepHole1 : (instr -> instr list option) -> stmt list -> unit
\end{ocamldoccode}
\index{peepHole1@\verb`peepHole1`}
\begin{ocamldocdescription}
Similar to {\tt{peepHole2}} except that the optimization window consists of 
    one instruction, not two


\end{ocamldocdescription}




{\bf Machine dependency}



\label{exception:Cil.SizeOfError}\begin{ocamldoccode}
exception SizeOfError of string * typ
\end{ocamldoccode}
\index{SizeOfError@\verb`SizeOfError`}
\begin{ocamldocdescription}
Raised when one of the bitsSizeOf functions cannot compute the size of a 
 type. This can happen because the type contains array-length expressions 
 that we don't know how to compute or because it is a type whose size is 
 not defined (e.g. TFun or an undefined compinfo). The string is an 
 explanation of the error


\end{ocamldocdescription}




\label{val:Cil.unsignedVersionOf}\begin{ocamldoccode}
val unsignedVersionOf : ikind -> ikind
\end{ocamldoccode}
\index{unsignedVersionOf@\verb`unsignedVersionOf`}
\begin{ocamldocdescription}
Give the unsigned kind corresponding to any integer kind


\end{ocamldocdescription}




\label{val:Cil.signedVersionOf}\begin{ocamldoccode}
val signedVersionOf : ikind -> ikind
\end{ocamldoccode}
\index{signedVersionOf@\verb`signedVersionOf`}
\begin{ocamldocdescription}
Give the signed kind corresponding to any integer kind


\end{ocamldocdescription}




\label{val:Cil.intRank}\begin{ocamldoccode}
val intRank : ikind -> int
\end{ocamldoccode}
\index{intRank@\verb`intRank`}
\begin{ocamldocdescription}
Return the integer conversion rank of an integer kind


\end{ocamldocdescription}




\label{val:Cil.commonIntKind}\begin{ocamldoccode}
val commonIntKind : ikind -> ikind -> ikind
\end{ocamldoccode}
\index{commonIntKind@\verb`commonIntKind`}
\begin{ocamldocdescription}
Return the common integer kind of the two integer arguments, as
    defined in ISO C 6.3.1.8 ("Usual arithmetic conversions")


\end{ocamldocdescription}




\label{val:Cil.intKindForSize}\begin{ocamldoccode}
val intKindForSize : int -> bool -> ikind
\end{ocamldoccode}
\index{intKindForSize@\verb`intKindForSize`}
\begin{ocamldocdescription}
The signed integer kind for a given size (unsigned if second argument
 is true). Raises Not\_found if no such kind exists


\end{ocamldocdescription}




\label{val:Cil.floatKindForSize}\begin{ocamldoccode}
val floatKindForSize : int -> fkind
\end{ocamldoccode}
\index{floatKindForSize@\verb`floatKindForSize`}
\begin{ocamldocdescription}
The float kind for a given size. Raises Not\_found
  if no such kind exists


\end{ocamldocdescription}




\label{val:Cil.bytesSizeOfInt}\begin{ocamldoccode}
val bytesSizeOfInt : ikind -> int
\end{ocamldoccode}
\index{bytesSizeOfInt@\verb`bytesSizeOfInt`}
\begin{ocamldocdescription}
The size in bytes of the given int kind.


\end{ocamldocdescription}




\label{val:Cil.bitsSizeOf}\begin{ocamldoccode}
val bitsSizeOf : typ -> int
\end{ocamldoccode}
\index{bitsSizeOf@\verb`bitsSizeOf`}
\begin{ocamldocdescription}
The size of a type, in bits. Trailing padding is added for structs and 
 arrays. Raises {\tt{Cil.SizeOfError}}[\ref{exception:Cil.SizeOfError}] when it cannot compute the size. This 
 function is architecture dependent, so you should only call this after you 
 call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}]. Remember that on GCC sizeof(void) is 1!


\end{ocamldocdescription}




\label{val:Cil.truncateCilint}\begin{ocamldoccode}
val truncateCilint :
  ikind -> Cilint.cilint -> Cilint.cilint * Cilint.truncation
\end{ocamldoccode}
\index{truncateCilint@\verb`truncateCilint`}
\begin{ocamldocdescription}
Represents an integer as for a given kind.  Returns a truncation
 flag saying that the value fit in the kind (NoTruncation), didn't
 fit but no "interesting" bits (all-0 or all-1) were lost
 (ValueTruncation) or that bits were lost (BitTruncation). Another 
 way to look at the ValueTruncation result is that if you had used
 the kind of opposite signedness (e.g. IUInt rather than IInt), you
 would gave got NoTruncation$\ldots$


\end{ocamldocdescription}




\label{val:Cil.fitsInInt}\begin{ocamldoccode}
val fitsInInt : ikind -> Cilint.cilint -> bool
\end{ocamldoccode}
\index{fitsInInt@\verb`fitsInInt`}
\begin{ocamldocdescription}
True if the integer fits within the kind's range


\end{ocamldocdescription}




\label{val:Cil.intKindForValue}\begin{ocamldoccode}
val intKindForValue : Cilint.cilint -> bool -> ikind
\end{ocamldoccode}
\index{intKindForValue@\verb`intKindForValue`}
\begin{ocamldocdescription}
Return the smallest kind that will hold the integer's value.  The
 kind will be unsigned if the 2nd argument is true, signed
 otherwise.  Note that if the value doesn't fit in any of the
 available types, you will get ILongLong (2nd argument false) or
 IULongLong (2nd argument true).


\end{ocamldocdescription}




\label{val:Cil.mkCilint}\begin{ocamldoccode}
val mkCilint : ikind -> int64 -> Cilint.cilint
\end{ocamldoccode}
\index{mkCilint@\verb`mkCilint`}
\begin{ocamldocdescription}
Construct a cilint from an integer kind and int64 value. Used for
 getting the actual constant value from a CInt64(n, ik, \_)
 constant.


\end{ocamldocdescription}




\label{val:Cil.sizeOf}\begin{ocamldoccode}
val sizeOf : typ -> exp
\end{ocamldoccode}
\index{sizeOf@\verb`sizeOf`}
\begin{ocamldocdescription}
The size of a type, in bytes. Returns a constant expression or a
 "sizeof" expression if it cannot compute the size. This function
 is architecture dependent, so you should only call this after you
 call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}].


\end{ocamldocdescription}




\label{val:Cil.alignOf-underscoreint}\begin{ocamldoccode}
val alignOf_int : typ -> int
\end{ocamldoccode}
\index{alignOf-underscoreint@\verb`alignOf_int`}
\begin{ocamldocdescription}
The minimum alignment (in bytes) for a type. This function is 
 architecture dependent, so you should only call this after you call 
 {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}].


\end{ocamldocdescription}




\label{val:Cil.bitsOffset}\begin{ocamldoccode}
val bitsOffset : typ -> offset -> int * int
\end{ocamldoccode}
\index{bitsOffset@\verb`bitsOffset`}
\begin{ocamldocdescription}
Give a type of a base and an offset, returns the number of bits from the 
 base address and the width (also expressed in bits) for the subobject 
 denoted by the offset. Raises {\tt{Cil.SizeOfError}}[\ref{exception:Cil.SizeOfError}] when it cannot compute 
 the size. This function is architecture dependent, so you should only call 
 this after you call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}].


\end{ocamldocdescription}




\label{val:Cil.char-underscoreis-underscoreunsigned}\begin{ocamldoccode}
val char_is_unsigned : bool ref
\end{ocamldoccode}
\index{char-underscoreis-underscoreunsigned@\verb`char_is_unsigned`}
\begin{ocamldocdescription}
Whether "char" is unsigned. Set after you call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}]


\end{ocamldocdescription}




\label{val:Cil.little-underscoreendian}\begin{ocamldoccode}
val little_endian : bool ref
\end{ocamldoccode}
\index{little-underscoreendian@\verb`little_endian`}
\begin{ocamldocdescription}
Whether the machine is little endian. Set after you call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}]


\end{ocamldocdescription}




\label{val:Cil.underscore-underscorename}\begin{ocamldoccode}
val underscore_name : bool ref
\end{ocamldoccode}
\index{underscore-underscorename@\verb`underscore_name`}
\begin{ocamldocdescription}
Whether the compiler generates assembly labels by prepending "\_" to the 
    identifier. That is, will function foo() have the label "foo", or "\_foo"?
    Set after you call {\tt{Cil.initCIL}}[\ref{val:Cil.initCIL}]


\end{ocamldocdescription}




\label{val:Cil.locUnknown}\begin{ocamldoccode}
val locUnknown : location
\end{ocamldoccode}
\index{locUnknown@\verb`locUnknown`}
\begin{ocamldocdescription}
Represents a location that cannot be determined


\end{ocamldocdescription}




\label{val:Cil.get-underscoreinstrLoc}\begin{ocamldoccode}
val get_instrLoc : instr -> location
\end{ocamldoccode}
\index{get-underscoreinstrLoc@\verb`get_instrLoc`}
\begin{ocamldocdescription}
Return the location of an instruction


\end{ocamldocdescription}




\label{val:Cil.get-underscoreglobalLoc}\begin{ocamldoccode}
val get_globalLoc : global -> location
\end{ocamldoccode}
\index{get-underscoreglobalLoc@\verb`get_globalLoc`}
\begin{ocamldocdescription}
Return the location of a global, or locUnknown


\end{ocamldocdescription}




\label{val:Cil.get-underscorestmtLoc}\begin{ocamldoccode}
val get_stmtLoc : stmtkind -> location
\end{ocamldoccode}
\index{get-underscorestmtLoc@\verb`get_stmtLoc`}
\begin{ocamldocdescription}
Return the location of a statement, or locUnknown


\end{ocamldocdescription}




\label{val:Cil.dExp}\begin{ocamldoccode}
val dExp : Pretty.doc -> exp
\end{ocamldoccode}
\index{dExp@\verb`dExp`}
\begin{ocamldocdescription}
Generate an {\tt{Cil.exp}}[\ref{type:Cil.exp}] to be used in case of errors.


\end{ocamldocdescription}




\label{val:Cil.dInstr}\begin{ocamldoccode}
val dInstr : Pretty.doc -> location -> instr
\end{ocamldoccode}
\index{dInstr@\verb`dInstr`}
\begin{ocamldocdescription}
Generate an {\tt{Cil.instr}}[\ref{type:Cil.instr}] to be used in case of errors.


\end{ocamldocdescription}




\label{val:Cil.dGlobal}\begin{ocamldoccode}
val dGlobal : Pretty.doc -> location -> global
\end{ocamldoccode}
\index{dGlobal@\verb`dGlobal`}
\begin{ocamldocdescription}
Generate a {\tt{Cil.global}}[\ref{type:Cil.global}] to be used in case of errors.


\end{ocamldocdescription}




\label{val:Cil.mapNoCopy}\begin{ocamldoccode}
val mapNoCopy : ('a -> 'a) -> 'a list -> 'a list
\end{ocamldoccode}
\index{mapNoCopy@\verb`mapNoCopy`}
\begin{ocamldocdescription}
Like map but try not to make a copy of the list


\end{ocamldocdescription}




\label{val:Cil.mapNoCopyList}\begin{ocamldoccode}
val mapNoCopyList : ('a -> 'a list) -> 'a list -> 'a list
\end{ocamldoccode}
\index{mapNoCopyList@\verb`mapNoCopyList`}
\begin{ocamldocdescription}
Like map but each call can return a list. Try not to make a copy of the 
    list


\end{ocamldocdescription}




\label{val:Cil.startsWith}\begin{ocamldoccode}
val startsWith : string -> string -> bool
\end{ocamldoccode}
\index{startsWith@\verb`startsWith`}
\begin{ocamldocdescription}
sm: return true if the first is a prefix of the second string


\end{ocamldocdescription}




\label{val:Cil.endsWith}\begin{ocamldoccode}
val endsWith : string -> string -> bool
\end{ocamldoccode}
\index{endsWith@\verb`endsWith`}
\begin{ocamldocdescription}
return true if the first is a suffix of the second string


\end{ocamldocdescription}




\label{val:Cil.stripUnderscores}\begin{ocamldoccode}
val stripUnderscores : string -> string
\end{ocamldoccode}
\index{stripUnderscores@\verb`stripUnderscores`}
\begin{ocamldocdescription}
If string has leading and trailing \_\_, strip them.


\end{ocamldocdescription}




{\bf An Interpreter for constructing CIL constructs}



\label{type:Cil.formatArg}\begin{ocamldoccode}
type formatArg =
  | Fe of exp
  | Feo of exp option
\end{ocamldoccode}
\begin{ocamldoccomment}
For array lengths
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Fu of unop
  | Fb of binop
  | Fk of ikind
  | FE of exp list
\end{ocamldoccode}
\begin{ocamldoccomment}
For arguments in a function call
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Ff of (string * typ * attributes)
\end{ocamldoccode}
\begin{ocamldoccomment}
For a formal argument
\end{ocamldoccomment}
\begin{ocamldoccode}
  | FF of (string * typ * attributes) list
\end{ocamldoccode}
\begin{ocamldoccomment}
For formal argument lists
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Fva of bool
\end{ocamldoccode}
\begin{ocamldoccomment}
For the ellipsis in a function type
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Fv of varinfo
  | Fl of lval
  | Flo of lval option
  | Fo of offset
  | Fc of compinfo
  | Fi of instr
  | FI of instr list
  | Ft of typ
  | Fd of int
  | Fg of string
  | Fs of stmt
  | FS of stmt list
  | FA of attributes
  | Fp of attrparam
  | FP of attrparam list
  | FX of string
\end{ocamldoccode}
\index{formatArg@\verb`formatArg`}
\begin{ocamldocdescription}
The type of argument for the interpreter


\end{ocamldocdescription}




\label{val:Cil.d-underscoreformatarg}\begin{ocamldoccode}
val d_formatarg : unit -> formatArg -> Pretty.doc
\end{ocamldoccode}
\index{d-underscoreformatarg@\verb`d_formatarg`}
\begin{ocamldocdescription}
Pretty-prints a format arg


\end{ocamldocdescription}




\label{val:Cil.warnTruncate}\begin{ocamldoccode}
val warnTruncate : bool ref
\end{ocamldoccode}
\index{warnTruncate@\verb`warnTruncate`}
\begin{ocamldocdescription}
Emit warnings when truncating integer constants (default true)


\end{ocamldocdescription}




\label{val:Cil.envMachine}\begin{ocamldoccode}
val envMachine : Machdep.mach option ref
\end{ocamldoccode}
\index{envMachine@\verb`envMachine`}
\begin{ocamldocdescription}
Machine model specified via CIL\_MACHINE environment variable


\end{ocamldocdescription}




\label{val:Cil.convertInts}\begin{ocamldoccode}
val convertInts : int64 -> ikind -> int64 -> ikind -> int64 * int64 * ikind
\end{ocamldoccode}
\index{convertInts@\verb`convertInts`}
\begin{ocamldocdescription}
{\it Deprecated. }. Convert two int64/kind pairs to a common int64/int64/kind triple.
\end{ocamldocdescription}




\label{val:Cil.isInteger}\begin{ocamldoccode}
val isInteger : exp -> int64 option
\end{ocamldoccode}
\index{isInteger@\verb`isInteger`}
\begin{ocamldocdescription}
{\it Deprecated. }. Can't handle large 64-bit unsigned constants
    correctly - use getInteger instead. If the given expression
    is a (possibly cast'ed) character or an integer constant, return
    that integer.  Otherwise, return None.
\end{ocamldocdescription}




\label{val:Cil.truncateInteger64}\begin{ocamldoccode}
val truncateInteger64 : ikind -> int64 -> int64 * bool
\end{ocamldoccode}
\index{truncateInteger64@\verb`truncateInteger64`}
\begin{ocamldocdescription}
{\it Deprecated. }. Use truncateCilint instead. Represents an integer as
 for a given kind.  Returns a flag saying whether the value was
 changed during truncation (because it was too large to fit in k).
\end{ocamldocdescription}




\label{val:Cil.gccBuiltins}\begin{ocamldoccode}
val gccBuiltins : (string, typ * typ list * bool) Hashtbl.t
\end{ocamldoccode}
\index{gccBuiltins@\verb`gccBuiltins`}
\begin{ocamldocdescription}
{\it Deprecated. }.  For compatibility with older programs, these are
    aliases for {\tt{Cil.builtinFunctions}}[\ref{val:Cil.builtinFunctions}]
\end{ocamldocdescription}




\label{val:Cil.msvcBuiltins}\begin{ocamldoccode}
val msvcBuiltins : (string, typ * typ list * bool) Hashtbl.t
\end{ocamldoccode}
\index{msvcBuiltins@\verb`msvcBuiltins`}
\begin{ocamldocdescription}
{\it Deprecated. }.  For compatibility with older programs, these are
  aliases for {\tt{Cil.builtinFunctions}}[\ref{val:Cil.builtinFunctions}]
\end{ocamldocdescription}


\section{Module {\tt{Formatcil}} : An Interpreter for constructing CIL constructs}
\label{module:Formatcil}\index{Formatcil@\verb`Formatcil`}




\ocamldocvspace{0.5cm}



\label{val:Formatcil.cExp}\begin{ocamldoccode}
val cExp : string -> (string * Cil.formatArg) list -> Cil.exp
\end{ocamldoccode}
\index{cExp@\verb`cExp`}
\begin{ocamldocdescription}
Constructs an expression based on the program and the list of arguments. 
 Each argument consists of a name followed by the actual data. This 
 argument will be placed instead of occurrences of "\%v:name" in the pattern 
 (where the "v" is dependent on the type of the data). The parsing of the 
 string is memoized. * Only the first expression is parsed.


\end{ocamldocdescription}




\label{val:Formatcil.cLval}\begin{ocamldoccode}
val cLval : string -> (string * Cil.formatArg) list -> Cil.lval
\end{ocamldoccode}
\index{cLval@\verb`cLval`}
\begin{ocamldocdescription}
Constructs an lval based on the program and the list of arguments. 
 Only the first lvalue is parsed. 
 The parsing of the string is memoized.


\end{ocamldocdescription}




\label{val:Formatcil.cType}\begin{ocamldoccode}
val cType : string -> (string * Cil.formatArg) list -> Cil.typ
\end{ocamldoccode}
\index{cType@\verb`cType`}
\begin{ocamldocdescription}
Constructs a type based on the program and the list of arguments. 
 Only the first type is parsed. 
 The parsing of the string is memoized.


\end{ocamldocdescription}




\label{val:Formatcil.cInstr}\begin{ocamldoccode}
val cInstr :
  string -> Cil.location -> (string * Cil.formatArg) list -> Cil.instr
\end{ocamldoccode}
\index{cInstr@\verb`cInstr`}
\begin{ocamldocdescription}
Constructs an instruction based on the program and the list of arguments. 
 Only the first instruction is parsed. 
 The parsing of the string is memoized.


\end{ocamldocdescription}




\label{val:Formatcil.cStmt}\begin{ocamldoccode}
val cStmt :
  string ->
  (string -> Cil.typ -> Cil.varinfo) ->
  Cil.location -> (string * Cil.formatArg) list -> Cil.stmt
\end{ocamldoccode}
\index{cStmt@\verb`cStmt`}




\label{val:Formatcil.cStmts}\begin{ocamldoccode}
val cStmts :
  string ->
  (string -> Cil.typ -> Cil.varinfo) ->
  Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list
\end{ocamldoccode}
\index{cStmts@\verb`cStmts`}
\begin{ocamldocdescription}
Constructs a list of statements


\end{ocamldocdescription}




\label{val:Formatcil.dExp}\begin{ocamldoccode}
val dExp : string -> Cil.exp -> Cil.formatArg list option
\end{ocamldoccode}
\index{dExp@\verb`dExp`}
\begin{ocamldocdescription}
Deconstructs an expression based on the program. Produces an optional 
 list of format arguments. The parsing of the string is memoized.


\end{ocamldocdescription}




\label{val:Formatcil.dLval}\begin{ocamldoccode}
val dLval : string -> Cil.lval -> Cil.formatArg list option
\end{ocamldoccode}
\index{dLval@\verb`dLval`}
\begin{ocamldocdescription}
Deconstructs an lval based on the program. Produces an optional 
 list of format arguments. The parsing of the string is memoized.


\end{ocamldocdescription}




\label{val:Formatcil.dType}\begin{ocamldoccode}
val dType : string -> Cil.typ -> Cil.formatArg list option
\end{ocamldoccode}
\index{dType@\verb`dType`}
\begin{ocamldocdescription}
Deconstructs a type based on the program. Produces an optional list of 
 format arguments. The parsing of the string is memoized.


\end{ocamldocdescription}




\label{val:Formatcil.dInstr}\begin{ocamldoccode}
val dInstr : string -> Cil.instr -> Cil.formatArg list option
\end{ocamldoccode}
\index{dInstr@\verb`dInstr`}
\begin{ocamldocdescription}
Deconstructs an instruction based on the program. Produces an optional 
 list of format arguments. The parsing of the string is memoized.


\end{ocamldocdescription}




\label{val:Formatcil.noMemoize}\begin{ocamldoccode}
val noMemoize : bool ref
\end{ocamldoccode}
\index{noMemoize@\verb`noMemoize`}
\begin{ocamldocdescription}
If set then will not memoize the parsed patterns


\end{ocamldocdescription}




\label{val:Formatcil.test}\begin{ocamldoccode}
val test : unit -> unit
\end{ocamldoccode}
\index{test@\verb`test`}
\begin{ocamldocdescription}
Just a testing function


\end{ocamldocdescription}


\section{Module {\tt{Alpha}} : ALPHA conversion}
\label{module:Alpha}\index{Alpha@\verb`Alpha`}




\ocamldocvspace{0.5cm}



\label{type:Alpha.undoAlphaElement}\begin{ocamldoccode}
type 'a undoAlphaElement 
\end{ocamldoccode}
\index{undoAlphaElement@\verb`undoAlphaElement`}
\begin{ocamldocdescription}
This is the type of the elements that are recorded by the alpha 
 conversion functions in order to be able to undo changes to the tables 
 they modify. Useful for implementing 
 scoping


\end{ocamldocdescription}




\label{type:Alpha.alphaTableData}\begin{ocamldoccode}
type 'a alphaTableData 
\end{ocamldoccode}
\index{alphaTableData@\verb`alphaTableData`}
\begin{ocamldocdescription}
This is the type of the elements of the alpha renaming table. These 
 elements can carry some data associated with each occurrence of the name.


\end{ocamldocdescription}




\label{val:Alpha.newAlphaName}\begin{ocamldoccode}
val newAlphaName :
  alphaTable:(string, 'a alphaTableData ref) Hashtbl.t ->
  undolist:'a undoAlphaElement list ref option ->
  lookupname:string -> data:'a -> string * 'a
\end{ocamldoccode}
\index{newAlphaName@\verb`newAlphaName`}
\begin{ocamldocdescription}
Create a new name based on a given name. The new name is formed from a 
 prefix (obtained from the given name by stripping a suffix consisting of \_\_\_
 followed by up to 9 digits), followed by a special separator and then by a 
 positive integer suffix. The first argument is a table mapping name 
 prefixes to some data that specifies what suffixes have been used and how 
 to create the new one. This function updates the table with the new 
 largest suffix generated. The "undolist" argument, when present, will be 
 used by the function to record information that can be used by 
 {\tt{Alpha.undoAlphaChanges}}[\ref{val:Alpha.undoAlphaChanges}] to undo those changes. Note that the undo 
 information will be in reverse order in which the action occurred. Returns 
 the new name and, if different from the lookupname, the location of the 
 previous occurrence. This function knows about the location implicitly 
 from the {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}].


\end{ocamldocdescription}




\label{val:Alpha.registerAlphaName}\begin{ocamldoccode}
val registerAlphaName :
  alphaTable:(string, 'a alphaTableData ref) Hashtbl.t ->
  undolist:'a undoAlphaElement list ref option ->
  lookupname:string -> data:'a -> unit
\end{ocamldoccode}
\index{registerAlphaName@\verb`registerAlphaName`}
\begin{ocamldocdescription}
Register a name with an alpha conversion table to ensure that when later 
 we call newAlphaName we do not end up generating this one


\end{ocamldocdescription}




\label{val:Alpha.docAlphaTable}\begin{ocamldoccode}
val docAlphaTable :
  unit ->
  (string, 'a alphaTableData ref) Hashtbl.t -> Pretty.doc
\end{ocamldoccode}
\index{docAlphaTable@\verb`docAlphaTable`}
\begin{ocamldocdescription}
Split the name in preparation for newAlphaName. The prefix returned is 
    used to index into the hashtable. The next result value is a separator 
    (either empty or the separator chosen to separate the original name from 
     the index)


\end{ocamldocdescription}




\label{val:Alpha.getAlphaPrefix}\begin{ocamldoccode}
val getAlphaPrefix : lookupname:string -> string
\end{ocamldoccode}
\index{getAlphaPrefix@\verb`getAlphaPrefix`}




\label{val:Alpha.undoAlphaChanges}\begin{ocamldoccode}
val undoAlphaChanges :
  alphaTable:(string, 'a alphaTableData ref) Hashtbl.t ->
  undolist:'a undoAlphaElement list -> unit
\end{ocamldoccode}
\index{undoAlphaChanges@\verb`undoAlphaChanges`}
\begin{ocamldocdescription}
Undo the changes to a table


\end{ocamldocdescription}


\section{Module {\tt{Cillower}} : A number of lowering passes over CIL}
\label{module:Cillower}\index{Cillower@\verb`Cillower`}




\ocamldocvspace{0.5cm}



\label{val:Cillower.lowerEnumVisitor}\begin{ocamldoccode}
val lowerEnumVisitor : Cil.cilVisitor
\end{ocamldoccode}
\index{lowerEnumVisitor@\verb`lowerEnumVisitor`}
\begin{ocamldocdescription}
Replace enumeration constants with integer constants


\end{ocamldocdescription}


\section{Module {\tt{Cfg}} : Code to compute the control-flow graph of a function or file.}
\label{module:Cfg}\index{Cfg@\verb`Cfg`}
  
  This will fill in the {\tt{preds}} and {\tt{succs}} fields of {\tt{Cil.stmt}}[\ref{type:Cil.stmt}]


  This is required for several other extensions, such as {\tt{Dataflow}}[\ref{module:Dataflow}].



\ocamldocvspace{0.5cm}



\label{val:Cfg.computeFileCFG}\begin{ocamldoccode}
val computeFileCFG : Cil.file -> unit
\end{ocamldoccode}
\index{computeFileCFG@\verb`computeFileCFG`}
\begin{ocamldocdescription}
Compute the CFG for an entire file, by calling cfgFun on each function.


\end{ocamldocdescription}




\label{val:Cfg.clearFileCFG}\begin{ocamldoccode}
val clearFileCFG : Cil.file -> unit
\end{ocamldoccode}
\index{clearFileCFG@\verb`clearFileCFG`}
\begin{ocamldocdescription}
clear the sid, succs, and preds fields of each statement.


\end{ocamldocdescription}




\label{val:Cfg.cfgFun}\begin{ocamldoccode}
val cfgFun : Cil.fundec -> int
\end{ocamldoccode}
\index{cfgFun@\verb`cfgFun`}
\begin{ocamldocdescription}
Compute a control flow graph for fd.  Stmts in fd have preds and succs
  filled in


\end{ocamldocdescription}




\label{val:Cfg.clearCFGinfo}\begin{ocamldoccode}
val clearCFGinfo : Cil.fundec -> unit
\end{ocamldoccode}
\index{clearCFGinfo@\verb`clearCFGinfo`}
\begin{ocamldocdescription}
clear the sid, succs, and preds fields of each statment in a function


\end{ocamldocdescription}




\label{val:Cfg.printCfgChannel}\begin{ocamldoccode}
val printCfgChannel : out_channel -> Cil.fundec -> unit
\end{ocamldoccode}
\index{printCfgChannel@\verb`printCfgChannel`}
\begin{ocamldocdescription}
print control flow graph (in dot form) for fundec to channel


\end{ocamldocdescription}




\label{val:Cfg.printCfgFilename}\begin{ocamldoccode}
val printCfgFilename : string -> Cil.fundec -> unit
\end{ocamldoccode}
\index{printCfgFilename@\verb`printCfgFilename`}
\begin{ocamldocdescription}
Print control flow graph (in dot form) for fundec to file


\end{ocamldocdescription}




\label{val:Cfg.start-underscoreid}\begin{ocamldoccode}
val start_id : int ref
\end{ocamldoccode}
\index{start-underscoreid@\verb`start_id`}
\begin{ocamldocdescription}
Next statement id that will be assigned.


\end{ocamldocdescription}




\label{val:Cfg.allStmts}\begin{ocamldoccode}
val allStmts : Cil.file -> Cil.stmt list
\end{ocamldoccode}
\index{allStmts@\verb`allStmts`}
\begin{ocamldocdescription}
Return all statements in a file - valid after computeFileCfg only


\end{ocamldocdescription}


\section{Module {\tt{Dataflow}} : A framework for data flow analysis for CIL code.}
\label{module:Dataflow}\index{Dataflow@\verb`Dataflow`}
  Before using 
    this framework, you must initialize the Control-flow Graph for your
    program, e.g using {\tt{Cfg.computeFileCFG}}[\ref{val:Cfg.computeFileCFG}]



\ocamldocvspace{0.5cm}



\label{type:Dataflow.action}\begin{ocamldoccode}
type 'a action =
  | Default
\end{ocamldoccode}
\begin{ocamldoccomment}
The default action
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Done of 'a
\end{ocamldoccode}
\begin{ocamldoccomment}
Do not do the default action. Use this result
\end{ocamldoccomment}
\begin{ocamldoccode}
  | Post of ('a -> 'a)
\end{ocamldoccode}
\begin{ocamldoccomment}
The default action, followed by the given 
 transformer
\end{ocamldoccomment}
\index{action@\verb`action`}




\label{type:Dataflow.stmtaction}\begin{ocamldoccode}
type 'a stmtaction =
  | SDefault
\end{ocamldoccode}
\begin{ocamldoccomment}
The default action
\end{ocamldoccomment}
\begin{ocamldoccode}
  | SDone
\end{ocamldoccode}
\begin{ocamldoccomment}
Do not visit this statement or its successors
\end{ocamldoccomment}
\begin{ocamldoccode}
  | SUse of 'a
\end{ocamldoccode}
\begin{ocamldoccomment}
Visit the instructions and successors of this statement
                  as usual, but use the specified state instead of the 
                  one that was passed to doStmt
\end{ocamldoccomment}
\index{stmtaction@\verb`stmtaction`}




\label{type:Dataflow.guardaction}\begin{ocamldoccode}
type 'a guardaction =
  | GDefault
\end{ocamldoccode}
\begin{ocamldoccomment}
The default state
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GUse of 'a
\end{ocamldoccode}
\begin{ocamldoccomment}
Use this data for the branch
\end{ocamldoccomment}
\begin{ocamldoccode}
  | GUnreachable
\end{ocamldoccode}
\begin{ocamldoccomment}
The branch will never be taken.
\end{ocamldoccomment}
\index{guardaction@\verb`guardaction`}




\begin{ocamldoccode}
{\tt{module type }}{\tt{ForwardsTransfer}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:Dataflow.ForwardsTransfer}\index{ForwardsTransfer@\verb`ForwardsTransfer`}

\begin{ocamldocsigend}


\label{val:Dataflow.ForwardsTransfer.name}\begin{ocamldoccode}
val name : string
\end{ocamldoccode}
\index{name@\verb`name`}
\begin{ocamldocdescription}
For debugging purposes, the name of the analysis


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.debug}\begin{ocamldoccode}
val debug : bool ref
\end{ocamldoccode}
\index{debug@\verb`debug`}
\begin{ocamldocdescription}
Whether to turn on debugging


\end{ocamldocdescription}


\label{type:Dataflow.ForwardsTransfer.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}
\begin{ocamldocdescription}
The type of the data we compute for each block start. May be 
 imperative.


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.copy}\begin{ocamldoccode}
val copy : t -> t
\end{ocamldoccode}
\index{copy@\verb`copy`}
\begin{ocamldocdescription}
Make a deep copy of the data


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.stmtStartData}\begin{ocamldoccode}
val stmtStartData : t Inthash.t
\end{ocamldoccode}
\index{stmtStartData@\verb`stmtStartData`}
\begin{ocamldocdescription}
For each statement id, the data at the start. Not found in the hash 
 table means nothing is known about the state at this point. At the end 
 of the analysis this means that the block is not reachable.


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.pretty}\begin{ocamldoccode}
val pretty : unit -> t -> Pretty.doc
\end{ocamldoccode}
\index{pretty@\verb`pretty`}
\begin{ocamldocdescription}
Pretty-print the state


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.computeFirstPredecessor}\begin{ocamldoccode}
val computeFirstPredecessor : Cil.stmt -> t -> t
\end{ocamldoccode}
\index{computeFirstPredecessor@\verb`computeFirstPredecessor`}
\begin{ocamldocdescription}
Give the first value for a predecessors, compute the value to be set 
 for the block


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.combinePredecessors}\begin{ocamldoccode}
val combinePredecessors : Cil.stmt ->
  old:t ->
  t -> t option
\end{ocamldoccode}
\index{combinePredecessors@\verb`combinePredecessors`}
\begin{ocamldocdescription}
Take some old data for the start of a statement, and some new data for 
 the same point. Return None if the combination is identical to the old 
 data. Otherwise, compute the combination, and return it.


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.doInstr}\begin{ocamldoccode}
val doInstr : Cil.instr ->
  t -> t Dataflow.action
\end{ocamldoccode}
\index{doInstr@\verb`doInstr`}
\begin{ocamldocdescription}
The (forwards) transfer function for an instruction. The 
 {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] is set before calling this. The default action is to 
 continue with the state unchanged.


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.doStmt}\begin{ocamldoccode}
val doStmt : Cil.stmt ->
  t ->
  t Dataflow.stmtaction
\end{ocamldoccode}
\index{doStmt@\verb`doStmt`}
\begin{ocamldocdescription}
The (forwards) transfer function for a statement. The {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] 
 is set before calling this. The default action is to do the instructions
 in this statement, if applicable, and continue with the successors.


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.doGuard}\begin{ocamldoccode}
val doGuard : Cil.exp ->
  t ->
  t Dataflow.guardaction
\end{ocamldoccode}
\index{doGuard@\verb`doGuard`}
\begin{ocamldocdescription}
Generate the successor to an If statement assuming the given expression
 is nonzero.  Analyses that don't need guard information can return 
 GDefault; this is equivalent to returning GUse of the input.
 A return value of GUnreachable indicates that this half of the branch
 will not be taken and should not be explored.  This will be called
 twice per If, once for "then" and once for "else".


\end{ocamldocdescription}


\label{val:Dataflow.ForwardsTransfer.filterStmt}\begin{ocamldoccode}
val filterStmt : Cil.stmt -> bool
\end{ocamldoccode}
\index{filterStmt@\verb`filterStmt`}
\begin{ocamldocdescription}
Whether to put this statement in the worklist. This is called when a 
 block would normally be put in the worklist.


\end{ocamldocdescription}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{ForwardsDataFlow}}{\tt{ : }}\end{ocamldoccode}
\label{module:Dataflow.ForwardsDataFlow}\index{ForwardsDataFlow@\verb`ForwardsDataFlow`}

{\tt{functor (}}{\tt{T}}{\tt{ : }}{\tt{ForwardsTransfer}}{\tt{) -> }}\begin{ocamldocsigend}


\label{val:Dataflow.ForwardsDataFlow.compute}\begin{ocamldoccode}
val compute : Cil.stmt list -> unit
\end{ocamldoccode}
\index{compute@\verb`compute`}
\begin{ocamldocdescription}
Fill in the T.stmtStartData, given a number of initial statements to 
 start from. All of the initial statements must have some entry in 
 T.stmtStartData (i.e., the initial data should not be bottom)


\end{ocamldocdescription}
\end{ocamldocsigend}








\begin{ocamldoccode}
{\tt{module type }}{\tt{BackwardsTransfer}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:Dataflow.BackwardsTransfer}\index{BackwardsTransfer@\verb`BackwardsTransfer`}

\begin{ocamldocsigend}


\label{val:Dataflow.BackwardsTransfer.name}\begin{ocamldoccode}
val name : string
\end{ocamldoccode}
\index{name@\verb`name`}
\begin{ocamldocdescription}
For debugging purposes, the name of the analysis


\end{ocamldocdescription}


\label{val:Dataflow.BackwardsTransfer.debug}\begin{ocamldoccode}
val debug : bool ref
\end{ocamldoccode}
\index{debug@\verb`debug`}
\begin{ocamldocdescription}
Whether to turn on debugging


\end{ocamldocdescription}


\label{type:Dataflow.BackwardsTransfer.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}
\begin{ocamldocdescription}
The type of the data we compute for each block start. In many 
 presentations of backwards data flow analysis we maintain the 
 data at the block end. This is not easy to do with JVML because 
 a block has many exceptional ends. So we maintain the data for 
 the statement start.


\end{ocamldocdescription}


\label{val:Dataflow.BackwardsTransfer.pretty}\begin{ocamldoccode}
val pretty : unit -> t -> Pretty.doc
\end{ocamldoccode}
\index{pretty@\verb`pretty`}
\begin{ocamldocdescription}
Pretty-print the state


\end{ocamldocdescription}


\label{val:Dataflow.BackwardsTransfer.stmtStartData}\begin{ocamldoccode}
val stmtStartData : t Inthash.t
\end{ocamldoccode}
\index{stmtStartData@\verb`stmtStartData`}
\begin{ocamldocdescription}
For each block id, the data at the start. This data structure must be 
 initialized with the initial data for each block


\end{ocamldocdescription}


\label{val:Dataflow.BackwardsTransfer.funcExitData}\begin{ocamldoccode}
val funcExitData : t
\end{ocamldoccode}
\index{funcExitData@\verb`funcExitData`}
\begin{ocamldocdescription}
The data at function exit.  Used for statements with no successors.
      This is usually bottom, since we'll also use doStmt on Return 
      statements.


\end{ocamldocdescription}


\label{val:Dataflow.BackwardsTransfer.combineStmtStartData}\begin{ocamldoccode}
val combineStmtStartData : Cil.stmt ->
  old:t ->
  t -> t option
\end{ocamldoccode}
\index{combineStmtStartData@\verb`combineStmtStartData`}
\begin{ocamldocdescription}
When the analysis reaches the start of a block, combine the old data 
 with the one we have just computed. Return None if the combination is 
 the same as the old data, otherwise return the combination. In the 
 latter case, the predecessors of the statement are put on the working 
 list.


\end{ocamldocdescription}


\label{val:Dataflow.BackwardsTransfer.combineSuccessors}\begin{ocamldoccode}
val combineSuccessors : t ->
  t -> t
\end{ocamldoccode}
\index{combineSuccessors@\verb`combineSuccessors`}
\begin{ocamldocdescription}
Take the data from two successors and combine it


\end{ocamldocdescription}


\label{val:Dataflow.BackwardsTransfer.doStmt}\begin{ocamldoccode}
val doStmt : Cil.stmt -> t Dataflow.action
\end{ocamldoccode}
\index{doStmt@\verb`doStmt`}
\begin{ocamldocdescription}
The (backwards) transfer function for a branch. The {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] is 
 set before calling this. If it returns None, then we have some default 
 handling. Otherwise, the returned data is the data before the branch 
 (not considering the exception handlers)


\end{ocamldocdescription}


\label{val:Dataflow.BackwardsTransfer.doInstr}\begin{ocamldoccode}
val doInstr : Cil.instr ->
  t -> t Dataflow.action
\end{ocamldoccode}
\index{doInstr@\verb`doInstr`}
\begin{ocamldocdescription}
The (backwards) transfer function for an instruction. The 
 {\tt{Cil.currentLoc}}[\ref{val:Cil.currentLoc}] is set before calling this. If it returns None, then we 
 have some default handling. Otherwise, the returned data is the data 
 before the branch (not considering the exception handlers)


\end{ocamldocdescription}


\label{val:Dataflow.BackwardsTransfer.filterStmt}\begin{ocamldoccode}
val filterStmt : Cil.stmt -> Cil.stmt -> bool
\end{ocamldoccode}
\index{filterStmt@\verb`filterStmt`}
\begin{ocamldocdescription}
Whether to put this predecessor block in the worklist. We give the 
 predecessor and the block whose predecessor we are (and whose data has 
 changed)


\end{ocamldocdescription}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{BackwardsDataFlow}}{\tt{ : }}\end{ocamldoccode}
\label{module:Dataflow.BackwardsDataFlow}\index{BackwardsDataFlow@\verb`BackwardsDataFlow`}

{\tt{functor (}}{\tt{T}}{\tt{ : }}{\tt{BackwardsTransfer}}{\tt{) -> }}\begin{ocamldocsigend}


\label{val:Dataflow.BackwardsDataFlow.compute}\begin{ocamldoccode}
val compute : Cil.stmt list -> unit
\end{ocamldoccode}
\index{compute@\verb`compute`}
\begin{ocamldocdescription}
Fill in the T.stmtStartData, given a number of initial statements to 
 start from (the sinks for the backwards data flow). All of the statements
 (not just the initial ones!) must have some entry in T.stmtStartData 
 If you want to use bottom for the initial data, you should pass the
 complete list of statements to {\tt{compute}}, so that everything is visited.
 {\tt{find\_stmts}} may be useful here.


\end{ocamldocdescription}
\end{ocamldocsigend}








\label{val:Dataflow.find-underscorestmts}\begin{ocamldoccode}
val find_stmts : Cil.fundec -> Cil.stmt list * Cil.stmt list
\end{ocamldoccode}
\index{find-underscorestmts@\verb`find_stmts`}
\begin{ocamldocdescription}
Returns (all\_stmts, sink\_stmts), where all\_stmts is a list of the 
  statements in a function, and sink\_stmts is a list of the return statments
  (including statements that fall through the end of a void function).  
  Useful when you need an initial set of statements for
  BackwardsDataFlow.compute.


\end{ocamldocdescription}


\section{Module {\tt{Dominators}} : Compute dominators using data flow analysis}
\label{module:Dominators}\index{Dominators@\verb`Dominators`}




\ocamldocvspace{0.5cm}



Author: George Necula   
      5/28/2004 




\label{val:Dominators.computeIDom}\begin{ocamldoccode}
val computeIDom : ?doCFG:bool -> Cil.fundec -> Cil.stmt option Inthash.t
\end{ocamldoccode}
\index{computeIDom@\verb`computeIDom`}
\begin{ocamldocdescription}
Invoke on a code after filling in the CFG info and it computes the 
 immediate dominator information. We map each statement to its immediate 
 dominator (None for the start statement, and for the unreachable 
 statements).


\end{ocamldocdescription}




\label{type:Dominators.tree}\begin{ocamldoccode}
type tree 
\end{ocamldoccode}
\index{tree@\verb`tree`}




\label{val:Dominators.computeDomTree}\begin{ocamldoccode}
val computeDomTree :
  ?doCFG:bool -> Cil.fundec -> Cil.stmt option Inthash.t * tree
\end{ocamldoccode}
\index{computeDomTree@\verb`computeDomTree`}
\begin{ocamldocdescription}
returns the IDoms and a map from statement ids to 
  the set of statements that are dominated


\end{ocamldocdescription}




\label{val:Dominators.getIdom}\begin{ocamldoccode}
val getIdom : Cil.stmt option Inthash.t -> Cil.stmt -> Cil.stmt option
\end{ocamldoccode}
\index{getIdom@\verb`getIdom`}
\begin{ocamldocdescription}
This is like Inthash.find but gives an error if the information is 
 Not\_found


\end{ocamldocdescription}




\label{val:Dominators.dominates}\begin{ocamldoccode}
val dominates : Cil.stmt option Inthash.t -> Cil.stmt -> Cil.stmt -> bool
\end{ocamldoccode}
\index{dominates@\verb`dominates`}
\begin{ocamldocdescription}
Check whether one statement dominates another.


\end{ocamldocdescription}




\label{val:Dominators.children}\begin{ocamldoccode}
val children : tree -> Cil.stmt -> Cil.stmt list
\end{ocamldoccode}
\index{children@\verb`children`}
\begin{ocamldocdescription}
Return a list of statements dominated by the argument


\end{ocamldocdescription}




\label{type:Dominators.order}\begin{ocamldoccode}
type order =
  | PreOrder
  | PostOrder
\end{ocamldoccode}
\index{order@\verb`order`}




\label{val:Dominators.domTreeIter}\begin{ocamldoccode}
val domTreeIter : (Cil.stmt -> unit) -> order -> tree -> unit
\end{ocamldoccode}
\index{domTreeIter@\verb`domTreeIter`}
\begin{ocamldocdescription}
Iterate over a dominator tree


\end{ocamldocdescription}




\label{val:Dominators.findNaturalLoops}\begin{ocamldoccode}
val findNaturalLoops :
  Cil.fundec -> Cil.stmt option Inthash.t -> (Cil.stmt * Cil.stmt list) list
\end{ocamldoccode}
\index{findNaturalLoops@\verb`findNaturalLoops`}
\begin{ocamldocdescription}
Compute the start of the natural loops. This assumes that the "idom" 
 field has been computed. For each start, keep a list of origin of a back 
 edge. The loop consists of the loop start and all predecessors of the 
 origins of back edges, up to and including the loop start


\end{ocamldocdescription}


\end{document}